<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>语法 | 静水流深</title>
    <meta name="description" content="因上努力 果上随缘">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.54626788.css" as="style"><link rel="preload" href="/assets/js/app.94455cae.js" as="script"><link rel="preload" href="/assets/js/3.46e2d97a.js" as="script"><link rel="preload" href="/assets/js/73.23b44a71.js" as="script"><link rel="prefetch" href="/assets/js/1.31cf2ec8.js"><link rel="prefetch" href="/assets/js/10.1b115c18.js"><link rel="prefetch" href="/assets/js/100.48ac91c6.js"><link rel="prefetch" href="/assets/js/101.d6ebf40b.js"><link rel="prefetch" href="/assets/js/102.d51b5998.js"><link rel="prefetch" href="/assets/js/103.dacdae82.js"><link rel="prefetch" href="/assets/js/104.eaafbc6b.js"><link rel="prefetch" href="/assets/js/105.387bcd14.js"><link rel="prefetch" href="/assets/js/106.7aadd79d.js"><link rel="prefetch" href="/assets/js/107.fa96ea52.js"><link rel="prefetch" href="/assets/js/108.2ac2e870.js"><link rel="prefetch" href="/assets/js/109.003466c2.js"><link rel="prefetch" href="/assets/js/11.36aed0a1.js"><link rel="prefetch" href="/assets/js/110.7b785169.js"><link rel="prefetch" href="/assets/js/111.aa26d5a8.js"><link rel="prefetch" href="/assets/js/112.a4f7a2af.js"><link rel="prefetch" href="/assets/js/113.58f60ffb.js"><link rel="prefetch" href="/assets/js/114.5f4f3292.js"><link rel="prefetch" href="/assets/js/115.6e608edf.js"><link rel="prefetch" href="/assets/js/116.c3f52f15.js"><link rel="prefetch" href="/assets/js/117.d0f1ee75.js"><link rel="prefetch" href="/assets/js/118.0d02556b.js"><link rel="prefetch" href="/assets/js/119.3be8cf42.js"><link rel="prefetch" href="/assets/js/12.b069f455.js"><link rel="prefetch" href="/assets/js/120.71898050.js"><link rel="prefetch" href="/assets/js/121.e683102c.js"><link rel="prefetch" href="/assets/js/122.3870a1bc.js"><link rel="prefetch" href="/assets/js/123.b6709d56.js"><link rel="prefetch" href="/assets/js/124.4056a7fc.js"><link rel="prefetch" href="/assets/js/125.05c0cff6.js"><link rel="prefetch" href="/assets/js/126.bbcde9c3.js"><link rel="prefetch" href="/assets/js/127.f78e81b9.js"><link rel="prefetch" href="/assets/js/128.59121021.js"><link rel="prefetch" href="/assets/js/129.daaddb18.js"><link rel="prefetch" href="/assets/js/13.2a546bf0.js"><link rel="prefetch" href="/assets/js/130.00f0a837.js"><link rel="prefetch" href="/assets/js/131.563da5dc.js"><link rel="prefetch" href="/assets/js/132.43e9a8e5.js"><link rel="prefetch" href="/assets/js/133.65b7f714.js"><link rel="prefetch" href="/assets/js/134.2f0de0be.js"><link rel="prefetch" href="/assets/js/135.cb3bfd28.js"><link rel="prefetch" href="/assets/js/136.54e69925.js"><link rel="prefetch" href="/assets/js/137.3becf6c6.js"><link rel="prefetch" href="/assets/js/138.d8fcc8fe.js"><link rel="prefetch" href="/assets/js/14.aee2ba7b.js"><link rel="prefetch" href="/assets/js/15.5d899dd9.js"><link rel="prefetch" href="/assets/js/16.0f1c1851.js"><link rel="prefetch" href="/assets/js/17.a673a300.js"><link rel="prefetch" href="/assets/js/18.1f5949af.js"><link rel="prefetch" href="/assets/js/19.1216bbbd.js"><link rel="prefetch" href="/assets/js/20.3fc002f0.js"><link rel="prefetch" href="/assets/js/21.65c965a2.js"><link rel="prefetch" href="/assets/js/22.137ca28e.js"><link rel="prefetch" href="/assets/js/23.c459748a.js"><link rel="prefetch" href="/assets/js/24.364abb0a.js"><link rel="prefetch" href="/assets/js/25.25effd1b.js"><link rel="prefetch" href="/assets/js/26.a1d2675a.js"><link rel="prefetch" href="/assets/js/27.0be08613.js"><link rel="prefetch" href="/assets/js/28.70b8c17a.js"><link rel="prefetch" href="/assets/js/29.5adbd5e0.js"><link rel="prefetch" href="/assets/js/30.3843d933.js"><link rel="prefetch" href="/assets/js/31.b27ef3b1.js"><link rel="prefetch" href="/assets/js/32.fdbfc04d.js"><link rel="prefetch" href="/assets/js/33.7760da0f.js"><link rel="prefetch" href="/assets/js/34.437c690e.js"><link rel="prefetch" href="/assets/js/35.796574c9.js"><link rel="prefetch" href="/assets/js/36.0143110b.js"><link rel="prefetch" href="/assets/js/37.c0f92ebc.js"><link rel="prefetch" href="/assets/js/38.440d779f.js"><link rel="prefetch" href="/assets/js/39.969331f9.js"><link rel="prefetch" href="/assets/js/4.a318d046.js"><link rel="prefetch" href="/assets/js/40.194e12d5.js"><link rel="prefetch" href="/assets/js/41.3aac45e7.js"><link rel="prefetch" href="/assets/js/42.713db659.js"><link rel="prefetch" href="/assets/js/43.661ebb12.js"><link rel="prefetch" href="/assets/js/44.ec30c897.js"><link rel="prefetch" href="/assets/js/45.4eb712a2.js"><link rel="prefetch" href="/assets/js/46.b6a1b6c9.js"><link rel="prefetch" href="/assets/js/47.c1446395.js"><link rel="prefetch" href="/assets/js/48.c3cc0d04.js"><link rel="prefetch" href="/assets/js/49.58315dcf.js"><link rel="prefetch" href="/assets/js/5.c09621b5.js"><link rel="prefetch" href="/assets/js/50.9e53e77d.js"><link rel="prefetch" href="/assets/js/51.ec3fb7fc.js"><link rel="prefetch" href="/assets/js/52.f7798353.js"><link rel="prefetch" href="/assets/js/53.0e122f54.js"><link rel="prefetch" href="/assets/js/54.bf2cee05.js"><link rel="prefetch" href="/assets/js/55.c3e2dfb7.js"><link rel="prefetch" href="/assets/js/56.6c5ef542.js"><link rel="prefetch" href="/assets/js/57.97c73bf7.js"><link rel="prefetch" href="/assets/js/58.60793109.js"><link rel="prefetch" href="/assets/js/59.6d8d7ad9.js"><link rel="prefetch" href="/assets/js/6.816c4684.js"><link rel="prefetch" href="/assets/js/60.f30a98a7.js"><link rel="prefetch" href="/assets/js/61.16448d3e.js"><link rel="prefetch" href="/assets/js/62.1bfa5629.js"><link rel="prefetch" href="/assets/js/63.4097bfd8.js"><link rel="prefetch" href="/assets/js/64.e1c5e297.js"><link rel="prefetch" href="/assets/js/65.0712ea96.js"><link rel="prefetch" href="/assets/js/66.f2890611.js"><link rel="prefetch" href="/assets/js/67.8a17f3d4.js"><link rel="prefetch" href="/assets/js/68.985efa4e.js"><link rel="prefetch" href="/assets/js/69.752baca0.js"><link rel="prefetch" href="/assets/js/7.9d533feb.js"><link rel="prefetch" href="/assets/js/70.38be5e94.js"><link rel="prefetch" href="/assets/js/71.b1f8bb9d.js"><link rel="prefetch" href="/assets/js/72.48c072b5.js"><link rel="prefetch" href="/assets/js/74.0eee8813.js"><link rel="prefetch" href="/assets/js/75.d38a3d70.js"><link rel="prefetch" href="/assets/js/76.0c2c5d89.js"><link rel="prefetch" href="/assets/js/77.8cefe9be.js"><link rel="prefetch" href="/assets/js/78.070d2300.js"><link rel="prefetch" href="/assets/js/79.dfb36280.js"><link rel="prefetch" href="/assets/js/8.4433540c.js"><link rel="prefetch" href="/assets/js/80.e0e91da2.js"><link rel="prefetch" href="/assets/js/81.3494411f.js"><link rel="prefetch" href="/assets/js/82.3ece83c0.js"><link rel="prefetch" href="/assets/js/83.570c41b1.js"><link rel="prefetch" href="/assets/js/84.050c5052.js"><link rel="prefetch" href="/assets/js/85.0c6b55a8.js"><link rel="prefetch" href="/assets/js/86.6d7ee4ed.js"><link rel="prefetch" href="/assets/js/87.b051a4a6.js"><link rel="prefetch" href="/assets/js/88.5dbe0bf0.js"><link rel="prefetch" href="/assets/js/89.f33d7730.js"><link rel="prefetch" href="/assets/js/9.9a910bbd.js"><link rel="prefetch" href="/assets/js/90.08da77aa.js"><link rel="prefetch" href="/assets/js/91.35c67dac.js"><link rel="prefetch" href="/assets/js/92.bf002ee6.js"><link rel="prefetch" href="/assets/js/93.b1f55944.js"><link rel="prefetch" href="/assets/js/94.a6109a30.js"><link rel="prefetch" href="/assets/js/95.ae932d48.js"><link rel="prefetch" href="/assets/js/96.210d3793.js"><link rel="prefetch" href="/assets/js/97.ae6e9e5a.js"><link rel="prefetch" href="/assets/js/98.d7a25915.js"><link rel="prefetch" href="/assets/js/99.26da5087.js">
    <link rel="stylesheet" href="/assets/css/0.styles.54626788.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">静水流深</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/readBook/你不知道的JavaScript1/作用域是什么.html" class="sidebar-link">作用域是什么</a></li><li><a href="/readBook/你不知道的JavaScript1/词法作用域.html" class="sidebar-link">词法作用域</a></li><li><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html" class="sidebar-link">函数作用域和块作用域</a></li><li><a href="/readBook/你不知道的JavaScript1/提升.html" class="sidebar-link">提升</a></li><li><a href="/readBook/你不知道的JavaScript1/作用域闭包.html" class="sidebar-link">作用域闭包</a></li><li><a href="/readBook/你不知道的JavaScript1/关于this.html" class="sidebar-link">关于this</a></li><li><a href="/readBook/你不知道的JavaScript1/this全面解析.html" class="sidebar-link">this全面解析</a></li><li><a href="/readBook/你不知道的JavaScript1/对象.html" class="active sidebar-link">对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#内容" class="sidebar-link">内容</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#可计算属性名" class="sidebar-link">可计算属性名</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#属性与方法" class="sidebar-link">属性与方法</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#数组" class="sidebar-link">数组</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#复制对象" class="sidebar-link">复制对象</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#属性描述符" class="sidebar-link">属性描述符</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#不变性" class="sidebar-link">不变性</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#get" class="sidebar-link">[[Get]]</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#put" class="sidebar-link">[[Put]]</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#getter和setter" class="sidebar-link">Getter和Setter</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#存在性" class="sidebar-link">存在性</a></li></ul></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#遍历" class="sidebar-link">遍历</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/对象.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/readBook/你不知道的JavaScript1/混合对象类.html" class="sidebar-link">混合对象&quot;类&quot;</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h2> <p>对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。</p> <ul><li>声明形式(对象字面量):</li></ul> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObj = { 
  <span class="hljs-attr">key</span>: value
  <span class="hljs-comment">// ... </span>
};
</code></pre></div><ul><li>构造形式:</li></ul> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); 
myObj.key = value;
</code></pre></div><p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。</p> <h2 id="类型"><a href="#类型" class="header-anchor">#</a> 类型</h2> <p>在JavaScript中一共有6中主要类型(术语是&quot;语言类型&quot;)</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>object</li></ul> <p>简单数据类型:		
其中string、boolean、number、null 和 undefined属于简单基本类型,并不属于对象.	
null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 &quot;object&quot;。实际上，null 本身是基本类型。
PS: 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p> <p>对象:
对象除了我们自己手动创建的,JavaScript其实内置了很多对象,也可以说是对象的一个子类型.</p> <p>内置对象:</p> <ul><li>String</li> <li>Number</li> <li>Boolean</li> <li>Object</li> <li>Function</li> <li>Array</li> <li>Date</li> <li>RegExp</li> <li>Error</li></ul> <p>在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数(由 new 产生的函数调用——参见第 2 章)来使用.</p> <p>几点说明:</p> <ul><li>函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。</li> <li>通过字面量形式创建字符串,数字,布尔时,引擎会自动把字面量转换成 String 对象,Number对象,Boolean对象，所以它们是可以访对应对象内置的问属性和方法。</li> <li>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</li> <li>对于 Object、Array、Function 和 RegExp(正则表达式)来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量(这是肯定的,因为不管哪种形式一创建出来就是对象类型,不可能是其他类型,实际上是不存在字面量这一说的)。但是使用构造形式可以提供一些额外选项(内置)。</li> <li>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。</li></ul> <h2 id="内容"><a href="#内容" class="header-anchor">#</a> 内容</h2> <p>对象属性:由一些存储在特定命名位置的(任意类型的)值.	
属性名:存储在对象容器内部的属性的名称.属性值并不会存在对象内.而是通过属性名(就像指针,从技术角度来说就是引用)来指向这些值真正的存储位置(就像房门号一样).
属性名的两种形式:</p> <ul><li><p>使用.操作符.也是我们最常用的形式.它通常被称为&quot;属性访问&quot;. . 操作符会要求属性名满足标识符的命名规范.</p></li> <li><p>使用[&quot;..&quot;]语法进行访问.这个通常被称为&quot;键访问&quot;.[&quot;..&quot;]语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且[&quot;..&quot;]语法使用字符串来访问属性,如果你的属性名是一个变量,则可以使用书中的例子myObject[idx]形式进行访问.这也是最常使用&quot;键访问&quot;的情况.但如果idx是属性名则还是需写成myObject[&quot;idx&quot;]字符串形式.</p></li></ul> <p>注意: 书中说在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串 . 在ES6之前这段话是正确的,但是现在有了symbol. symbol也可以作为对象属性名使用,并且symbol是不可以转化为字符串形式的!</p> <h3 id="可计算属性名"><a href="#可计算属性名" class="header-anchor">#</a> 可计算属性名</h3> <p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> prefix = <span class="hljs-string">&quot;foo&quot;</span>;

<span class="hljs-keyword">var</span> myObject = {
   [prefix + <span class="hljs-string">&quot;bar&quot;</span>]:<span class="hljs-string">&quot;hello&quot;</span>, 
   [prefix + <span class="hljs-string">&quot;baz&quot;</span>]: <span class="hljs-string">&quot;world&quot;</span>
};
myObject[<span class="hljs-string">&quot;foobar&quot;</span>]; <span class="hljs-comment">// hello</span>
myObject[<span class="hljs-string">&quot;foobaz&quot;</span>]; <span class="hljs-comment">// world</span>
</code></pre></div><h3 id="属性与方法"><a href="#属性与方法" class="header-anchor">#</a> 属性与方法</h3> <p>我们经常把对象内部引用的函数称为“方法”(的确如此).
实际上函数并不属于该对象,它不过是对函数的引用罢了.对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。
即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。</p> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <p>数组支持 [] 形式访问储存的值,其中 [] 内的值默认形式为数值下标(为从0开始的整数,也就是常说的索引).例如myArray[0]
数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性.例如myArray.baz = &quot;baz&quot;.注意:添加新属性后,虽然可以访问,但数组的 length 值不会改变.
数组可以通过myArray[1]=11;myArray[&quot;2&quot;]=22;这种形式对数组内容进行修改,添加.
虽然数组也可以和对象一样通过键/值 对 形式来使用.但JS已经对数组的行为和用途进行了优化.所以还是建议使用默认的下标/值 对 形式来使用.</p> <h3 id="复制对象"><a href="#复制对象" class="header-anchor">#</a> 复制对象</h3> <p>复制分为浅拷贝和深拷贝.浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域),对于对象则是继续引用.而不是重新创建一个&quot;一样的&quot;对象.深拷贝则是对其中的所有内(容包括对象)进行深层次的复制.
一般情况下我们可以通过JSON来复制对象.var newObj = JSON.parse( JSON.stringify( someObj ) );.但需要指出的是这种方法对于包含function函数或者Date类型的对象则不管用!
ES6 定义了 Object.assign(..) 方法来实现浅复制。具体用法在这就不赘述了.</p> <h3 id="属性描述符"><a href="#属性描述符" class="header-anchor">#</a> 属性描述符</h3> <p>从 ES5 开始，所有的属性都具备了属性描述符。</p> <ul><li>查看属性描述符: 可以使用Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );方法查看myObject对象里属性a的属性描述符.</li> <li>配置属性描述符: 可以使用Object.defineProperty(..)方法对属性的属性描述符就像配置.举个例子:</li></ul> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObject = {};
<span class="hljs-built_in">Object</span>.defineProperty( myObject, <span class="hljs-string">&quot;a&quot;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>, 
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>, 
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
} );
myObject.a; <span class="hljs-comment">// 2</span>
<span class="hljs-comment">//该方法可以配置四个属性描述符</span>
</code></pre></div><p>下面分别介绍剩下的三个属性描述符键值:</p> <ol><li>Writable   决定是否可以修改属性的值。当被设置为false后,再对属性值进行修改,则会静默失败(silently failed,修改不成功,也不报错)了。如果在严格模式下，则会报出TypeError错误.</li> <li>Configurable 决定属性描述符是否可配置.如果为true,就可以使用 defineProperty(..) 方法来修改属性描述符.注意:不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且把 configurable 修改成 false 是单向操作，无法撤销! 但是有个例外即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性.</li> <li>Enumerable  决定该属性是否会出现在对象的属性枚举中.比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。</li></ol> <h3 id="不变性"><a href="#不变性" class="header-anchor">#</a> 不变性</h3> <p>除了上面提到的Object.defineProperty(..),ES5还可以通过很多种方法来实现属性或者对象的不可变.</p> <p>注意: 这些所有方法都是只能浅不变,如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的.类似于浅拷贝.</p> <p>说明:  在 JavaScript 程序中很少需要深不可变性。 有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。</p> <p>方法:</p> <ol><li>对象常量(不可改) 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除)</li> <li>禁止扩展(不可增) 使用 Object.prevent Extensions(myObject),可以禁止一个对象添加新属性并且保留已有属性.在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</li> <li>密封(不可配置,但可修改) 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</li> <li>冻结(不可配置,也不可修改) Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。</li></ol> <p>注意: 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎!因为你引用的对象可能会在其他地发也被引用.</p> <p>说明: 在 JavaScript 程序中很少需要深不可变性。有些特殊情况可能需要这样做， 但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。</p> <h3 id="get"><a href="#get" class="header-anchor">#</a> [[Get]]</h3> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObject = { 
   <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>
};
myObject.a; <span class="hljs-comment">// 2</span>
</code></pre></div><p>myObject.a是怎么取到值2的?</p> <p>myObject.a 通过对象默认内置的[[Get]] 操作(有点像函数调用:[Get]).首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined.</p> <p>注意: 如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常.</p> <h3 id="put"><a href="#put" class="header-anchor">#</a> [[Put]]</h3> <p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性.
[[Put]] 被触发时的操作分为两个情况:1. 对象中已经存在这个属性 2. 对象中不存在这个属性.
如果对象中已经存在这个属性,[[Put]] 算法大致会检查下面这些内容:</p> <ul><li>属性是否是访问描述符(参见下一节)?如果是并且存在setter就调用setter。</li> <li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li> <li>如果都不是，将该值设置为属性的值。</li></ul> <p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。会在第 5 章讨论 [[Prototype]] 时详细进行介绍。</p> <h3 id="getter和setter"><a href="#getter和setter" class="header-anchor">#</a> Getter和Setter</h3> <p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。	
目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ,但是在ES5中可以使用 getter 和 setter 改写部分默认操作,只能应用在单个属性上，无法应用在整个对象上。</p> <p>getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作.当你设置getter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性.</p> <p>语法: {get prop() { ... } }或{get <a href="">expression</a> { ... } }.其中prop:要设置的属性名. expression:从 ECMAScript 2015 开始可以使用计算属性名.</p> <p>使用方式:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObject = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1111</span>, <span class="hljs-comment">//在后面会发现myObject.a为2,这是因为设置了getter所以忽略了value特性.</span>
  <span class="hljs-comment">//方式一:在新对象初始化时定义一个getter</span>
  <span class="hljs-keyword">get</span> a() {
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
  }
};

<span class="hljs-built_in">Object</span>.defineProperty( 
  myObject, <span class="hljs-comment">// 目标对象 </span>
  <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 属性名</span>
  {
    <span class="hljs-comment">// 方式二:使用defineProperty在现有对象上定义 getter</span>
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a * <span class="hljs-number">2</span> },
    <span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span>
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
   }
);

myObject.a = <span class="hljs-number">3</span>;  <span class="hljs-comment">//因为设置了getter所以忽略了writable特性.所以这里赋值没成功</span>
myObject.a; <span class="hljs-comment">// 2</span>
myObject.b; <span class="hljs-comment">// 4</span>

<span class="hljs-keyword">delete</span> myObject.a;<span class="hljs-comment">//可以使用delete操作符删除</span>
</code></pre></div><p>setter:	
setter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).当你设置setter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性.
语法: {set prop(val) { . . . }}或{set <a href="val">expression</a> { . . . }}.其中prop:要设置的属性名. val:用于保存尝试分配给prop的值的变量的一个别名。expression:从 ECMAScript 2015 开始可以使用计算属性名.</p> <p>使用方式:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> myObject = {
  <span class="hljs-comment">//注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):</span>
  <span class="hljs-comment">//方式一:在新对象初始化时定义一个setter</span>
  <span class="hljs-keyword">set</span> a(val) {
    <span class="hljs-keyword">this</span>._a_ = val * <span class="hljs-number">2</span>
  },
  <span class="hljs-keyword">get</span> a() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._a_ 
  }
};

<span class="hljs-built_in">Object</span>.defineProperty( 
  myObject, <span class="hljs-comment">// 目标对象 </span>
  <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-comment">// 属性名</span>
  {
    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>{ <span class="hljs-keyword">this</span>._b_ = val * <span class="hljs-number">3</span> },
    <span class="hljs-comment">// 方式二:使用defineProperty在现有对象上定义 setter</span>
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._b_ },
    <span class="hljs-comment">// 确保 b 会出现在对象的属性列表中</span>
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>
   }
);

myObject.a = <span class="hljs-number">2</span>;  
myObject.b = <span class="hljs-number">3</span>;  
<span class="hljs-built_in">console</span>.log(myObject.a); <span class="hljs-comment">//4</span>
<span class="hljs-built_in">console</span>.log(myObject.b);<span class="hljs-comment">//9</span>

<span class="hljs-built_in">console</span>.log(myObject._a_);<span class="hljs-comment">//4</span>
<span class="hljs-built_in">console</span>.log(myObject._b_);<span class="hljs-comment">//9</span>

<span class="hljs-keyword">delete</span> myObject.a;<span class="hljs-comment">//可以使用delete操作符删除</span>
</code></pre></div><h3 id="存在性"><a href="#存在性" class="header-anchor">#</a> 存在性</h3> <p>属性存在性:	  	
如何判断一个对象是否存在某个属性(准确来说是检查这个属性名是否存在),这时就需要用到:</p> <p>in操作符
in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。</p> <p>hasOwnProperty(..)<br>
hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p> <p>注意:</p> <ol><li>如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,&quot;a&quot;)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第2章)到 myObject 上。</li> <li>对于数组来说,不要使用in操作符,因为它检查的是属性名,在数组中属性名就是索引,它并不是我们所关注的重点.对于数组我们更关注的是它所存的值,所以对于数组检查某个值是否存在还是采用indexOf方法.</li></ol> <p>属性可枚举性:	<br>
如果一个属性存在,且它的enumerable 属性描述符为true时.则它是可枚举的.并且可以被for..in 循环.	
一个属性不仅仅需要存在,还需要它的enumerable 为true才是可枚举的,才能被for...in遍历到.
注意: for...in不适合对数组进行遍历,对数组的遍历还是使用传统的for循环.
对属性的可枚举性判断,则需要用到以下几种方法:</p> <ol><li><p>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。</p></li> <li><p>Object.keys(..) 会返回一个数组，包含所有可枚举属性.</p></li> <li><p>Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</p></li></ol> <h2 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h2> <p>关于这节我觉得还是以理清for..in和for..of为主.后面延伸的@@iterator及Symbol.iterator的使用,没必要过于深究.注意书中123页第二行done 是一个布尔值，表示是否还有可以遍历的值。有个错误,应该改成done 是一个布尔值，表示遍历是否结束。否则你在看后面它的说明时会感觉到自相矛盾.这里我也是以for..in和for..of为主进行说明,也更贴近我们实际使用.</p> <p>for..in</p> <ul><li>for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。</li> <li>实际上for..in遍历的并不是属性值,而是属性名(即键名 key).所以你想获取属性值还是需要手动使用obj[key]来获取.</li> <li>一般在遍历对象时,推荐使用for..in.当然数组也是可以使用for..in的.在遍历数组时,推荐还是使用for..of.</li></ul> <p>for..of</p> <ul><li>ES6 增加了一种用来遍历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象)</li> <li>for..of与for..in最大的不同点是,它循环的是属性值,而不是属性名.不过它只循环数组里存放的值,不会涉及到对象里的key.(关于这个我后面的例子里会说具体对比明的)</li> <li>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator，(对象没有,所以不能使用for..of,除非我们自己定义一个)因此 for..of 可以直接应用在数组上。</li></ul> <p>例子比较</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'shotCat'</span>,<span class="hljs-number">111</span>,{<span class="hljs-attr">a</span>:<span class="hljs-string">'1'</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">'2'</span>}]
arr.say=<span class="hljs-string">&quot;IG niu pi!&quot;</span>
<span class="hljs-comment">//使用for..in循环</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> arr){
  <span class="hljs-built_in">console</span>.log(arr[index]);<span class="hljs-comment">//shotCat  111  {a:'1',b:'2'}  IG niu pi!</span>
}
<span class="hljs-comment">//使用for..of循环</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> arr){
  <span class="hljs-built_in">console</span>.log(value);<span class="hljs-comment">//shotCat  111  {a:'1',b:'2'}</span>
}
<span class="hljs-comment">//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值,不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会)</span>
</code></pre></div><p>如何让对象也能使用for..of ?</p> <p>通过Object.defineProperty()定义一个Symbol.iterator属性来实现</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <ul><li>JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。</li> <li>对象是 6 个(或者是 7 个，取决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</li> <li>对象就是键 / 值对的集合。可以通过 .propName 或者 [&quot;propName&quot;] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链(参见第 5 章)。</li> <li>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。</li> <li>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</li> <li>可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/readBook/你不知道的JavaScript1/this全面解析.html" class="prev">
        this全面解析
      </a></span> <span class="next"><a href="/readBook/你不知道的JavaScript1/混合对象类.html">
        混合对象&quot;类&quot;
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.94455cae.js" defer></script><script src="/assets/js/3.46e2d97a.js" defer></script><script src="/assets/js/73.23b44a71.js" defer></script>
  </body>
</html>
