<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数作用域和块作用域 | 静水流深</title>
    <meta name="description" content="因上努力 果上随缘">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.54626788.css" as="style"><link rel="preload" href="/assets/js/app.94455cae.js" as="script"><link rel="preload" href="/assets/js/3.46e2d97a.js" as="script"><link rel="preload" href="/assets/js/72.48c072b5.js" as="script"><link rel="prefetch" href="/assets/js/1.31cf2ec8.js"><link rel="prefetch" href="/assets/js/10.1b115c18.js"><link rel="prefetch" href="/assets/js/100.48ac91c6.js"><link rel="prefetch" href="/assets/js/101.d6ebf40b.js"><link rel="prefetch" href="/assets/js/102.d51b5998.js"><link rel="prefetch" href="/assets/js/103.dacdae82.js"><link rel="prefetch" href="/assets/js/104.eaafbc6b.js"><link rel="prefetch" href="/assets/js/105.387bcd14.js"><link rel="prefetch" href="/assets/js/106.7aadd79d.js"><link rel="prefetch" href="/assets/js/107.fa96ea52.js"><link rel="prefetch" href="/assets/js/108.2ac2e870.js"><link rel="prefetch" href="/assets/js/109.003466c2.js"><link rel="prefetch" href="/assets/js/11.36aed0a1.js"><link rel="prefetch" href="/assets/js/110.7b785169.js"><link rel="prefetch" href="/assets/js/111.aa26d5a8.js"><link rel="prefetch" href="/assets/js/112.a4f7a2af.js"><link rel="prefetch" href="/assets/js/113.58f60ffb.js"><link rel="prefetch" href="/assets/js/114.5f4f3292.js"><link rel="prefetch" href="/assets/js/115.6e608edf.js"><link rel="prefetch" href="/assets/js/116.c3f52f15.js"><link rel="prefetch" href="/assets/js/117.d0f1ee75.js"><link rel="prefetch" href="/assets/js/118.0d02556b.js"><link rel="prefetch" href="/assets/js/119.3be8cf42.js"><link rel="prefetch" href="/assets/js/12.b069f455.js"><link rel="prefetch" href="/assets/js/120.71898050.js"><link rel="prefetch" href="/assets/js/121.e683102c.js"><link rel="prefetch" href="/assets/js/122.3870a1bc.js"><link rel="prefetch" href="/assets/js/123.b6709d56.js"><link rel="prefetch" href="/assets/js/124.4056a7fc.js"><link rel="prefetch" href="/assets/js/125.05c0cff6.js"><link rel="prefetch" href="/assets/js/126.bbcde9c3.js"><link rel="prefetch" href="/assets/js/127.f78e81b9.js"><link rel="prefetch" href="/assets/js/128.59121021.js"><link rel="prefetch" href="/assets/js/129.daaddb18.js"><link rel="prefetch" href="/assets/js/13.2a546bf0.js"><link rel="prefetch" href="/assets/js/130.00f0a837.js"><link rel="prefetch" href="/assets/js/131.563da5dc.js"><link rel="prefetch" href="/assets/js/132.43e9a8e5.js"><link rel="prefetch" href="/assets/js/133.65b7f714.js"><link rel="prefetch" href="/assets/js/134.2f0de0be.js"><link rel="prefetch" href="/assets/js/135.cb3bfd28.js"><link rel="prefetch" href="/assets/js/136.54e69925.js"><link rel="prefetch" href="/assets/js/137.3becf6c6.js"><link rel="prefetch" href="/assets/js/138.d8fcc8fe.js"><link rel="prefetch" href="/assets/js/14.aee2ba7b.js"><link rel="prefetch" href="/assets/js/15.5d899dd9.js"><link rel="prefetch" href="/assets/js/16.0f1c1851.js"><link rel="prefetch" href="/assets/js/17.a673a300.js"><link rel="prefetch" href="/assets/js/18.1f5949af.js"><link rel="prefetch" href="/assets/js/19.1216bbbd.js"><link rel="prefetch" href="/assets/js/20.3fc002f0.js"><link rel="prefetch" href="/assets/js/21.65c965a2.js"><link rel="prefetch" href="/assets/js/22.137ca28e.js"><link rel="prefetch" href="/assets/js/23.c459748a.js"><link rel="prefetch" href="/assets/js/24.364abb0a.js"><link rel="prefetch" href="/assets/js/25.25effd1b.js"><link rel="prefetch" href="/assets/js/26.a1d2675a.js"><link rel="prefetch" href="/assets/js/27.0be08613.js"><link rel="prefetch" href="/assets/js/28.70b8c17a.js"><link rel="prefetch" href="/assets/js/29.5adbd5e0.js"><link rel="prefetch" href="/assets/js/30.3843d933.js"><link rel="prefetch" href="/assets/js/31.b27ef3b1.js"><link rel="prefetch" href="/assets/js/32.fdbfc04d.js"><link rel="prefetch" href="/assets/js/33.7760da0f.js"><link rel="prefetch" href="/assets/js/34.437c690e.js"><link rel="prefetch" href="/assets/js/35.796574c9.js"><link rel="prefetch" href="/assets/js/36.0143110b.js"><link rel="prefetch" href="/assets/js/37.c0f92ebc.js"><link rel="prefetch" href="/assets/js/38.440d779f.js"><link rel="prefetch" href="/assets/js/39.969331f9.js"><link rel="prefetch" href="/assets/js/4.a318d046.js"><link rel="prefetch" href="/assets/js/40.194e12d5.js"><link rel="prefetch" href="/assets/js/41.3aac45e7.js"><link rel="prefetch" href="/assets/js/42.713db659.js"><link rel="prefetch" href="/assets/js/43.661ebb12.js"><link rel="prefetch" href="/assets/js/44.ec30c897.js"><link rel="prefetch" href="/assets/js/45.4eb712a2.js"><link rel="prefetch" href="/assets/js/46.b6a1b6c9.js"><link rel="prefetch" href="/assets/js/47.c1446395.js"><link rel="prefetch" href="/assets/js/48.c3cc0d04.js"><link rel="prefetch" href="/assets/js/49.58315dcf.js"><link rel="prefetch" href="/assets/js/5.c09621b5.js"><link rel="prefetch" href="/assets/js/50.9e53e77d.js"><link rel="prefetch" href="/assets/js/51.ec3fb7fc.js"><link rel="prefetch" href="/assets/js/52.f7798353.js"><link rel="prefetch" href="/assets/js/53.0e122f54.js"><link rel="prefetch" href="/assets/js/54.bf2cee05.js"><link rel="prefetch" href="/assets/js/55.c3e2dfb7.js"><link rel="prefetch" href="/assets/js/56.6c5ef542.js"><link rel="prefetch" href="/assets/js/57.97c73bf7.js"><link rel="prefetch" href="/assets/js/58.60793109.js"><link rel="prefetch" href="/assets/js/59.6d8d7ad9.js"><link rel="prefetch" href="/assets/js/6.816c4684.js"><link rel="prefetch" href="/assets/js/60.f30a98a7.js"><link rel="prefetch" href="/assets/js/61.16448d3e.js"><link rel="prefetch" href="/assets/js/62.1bfa5629.js"><link rel="prefetch" href="/assets/js/63.4097bfd8.js"><link rel="prefetch" href="/assets/js/64.e1c5e297.js"><link rel="prefetch" href="/assets/js/65.0712ea96.js"><link rel="prefetch" href="/assets/js/66.f2890611.js"><link rel="prefetch" href="/assets/js/67.8a17f3d4.js"><link rel="prefetch" href="/assets/js/68.985efa4e.js"><link rel="prefetch" href="/assets/js/69.752baca0.js"><link rel="prefetch" href="/assets/js/7.9d533feb.js"><link rel="prefetch" href="/assets/js/70.38be5e94.js"><link rel="prefetch" href="/assets/js/71.b1f8bb9d.js"><link rel="prefetch" href="/assets/js/73.23b44a71.js"><link rel="prefetch" href="/assets/js/74.0eee8813.js"><link rel="prefetch" href="/assets/js/75.d38a3d70.js"><link rel="prefetch" href="/assets/js/76.0c2c5d89.js"><link rel="prefetch" href="/assets/js/77.8cefe9be.js"><link rel="prefetch" href="/assets/js/78.070d2300.js"><link rel="prefetch" href="/assets/js/79.dfb36280.js"><link rel="prefetch" href="/assets/js/8.4433540c.js"><link rel="prefetch" href="/assets/js/80.e0e91da2.js"><link rel="prefetch" href="/assets/js/81.3494411f.js"><link rel="prefetch" href="/assets/js/82.3ece83c0.js"><link rel="prefetch" href="/assets/js/83.570c41b1.js"><link rel="prefetch" href="/assets/js/84.050c5052.js"><link rel="prefetch" href="/assets/js/85.0c6b55a8.js"><link rel="prefetch" href="/assets/js/86.6d7ee4ed.js"><link rel="prefetch" href="/assets/js/87.b051a4a6.js"><link rel="prefetch" href="/assets/js/88.5dbe0bf0.js"><link rel="prefetch" href="/assets/js/89.f33d7730.js"><link rel="prefetch" href="/assets/js/9.9a910bbd.js"><link rel="prefetch" href="/assets/js/90.08da77aa.js"><link rel="prefetch" href="/assets/js/91.35c67dac.js"><link rel="prefetch" href="/assets/js/92.bf002ee6.js"><link rel="prefetch" href="/assets/js/93.b1f55944.js"><link rel="prefetch" href="/assets/js/94.a6109a30.js"><link rel="prefetch" href="/assets/js/95.ae932d48.js"><link rel="prefetch" href="/assets/js/96.210d3793.js"><link rel="prefetch" href="/assets/js/97.ae6e9e5a.js"><link rel="prefetch" href="/assets/js/98.d7a25915.js"><link rel="prefetch" href="/assets/js/99.26da5087.js">
    <link rel="stylesheet" href="/assets/css/0.styles.54626788.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">静水流深</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/readBook/你不知道的JavaScript1/作用域是什么.html" class="sidebar-link">作用域是什么</a></li><li><a href="/readBook/你不知道的JavaScript1/词法作用域.html" class="sidebar-link">词法作用域</a></li><li><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html" class="active sidebar-link">函数作用域和块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#函数中的作用域" class="sidebar-link">函数中的作用域</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#隐藏内部实现" class="sidebar-link">隐藏内部实现</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#函数作用域" class="sidebar-link">函数作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#匿名和具名" class="sidebar-link">匿名和具名</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#立即执行函数表达式" class="sidebar-link">立即执行函数表达式</a></li></ul></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#块作用域" class="sidebar-link">块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#with" class="sidebar-link">with</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#try-catch" class="sidebar-link">try/catch</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#let" class="sidebar-link">let</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#const" class="sidebar-link">const</a></li></ul></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/readBook/你不知道的JavaScript1/提升.html" class="sidebar-link">提升</a></li><li><a href="/readBook/你不知道的JavaScript1/作用域闭包.html" class="sidebar-link">作用域闭包</a></li><li><a href="/readBook/你不知道的JavaScript1/关于this.html" class="sidebar-link">关于this</a></li><li><a href="/readBook/你不知道的JavaScript1/this全面解析.html" class="sidebar-link">this全面解析</a></li><li><a href="/readBook/你不知道的JavaScript1/对象.html" class="sidebar-link">对象</a></li><li><a href="/readBook/你不知道的JavaScript1/混合对象类.html" class="sidebar-link">混合对象&quot;类&quot;</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="函数中的作用域"><a href="#函数中的作用域" class="header-anchor">#</a> 函数中的作用域</h2> <ul><li>JavaScript 具有基于函数的作用域，一般情况下每声明 一个函数都会创建一个函数作用域.</li> <li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。</li></ul> <h2 id="隐藏内部实现"><a href="#隐藏内部实现" class="header-anchor">#</a> 隐藏内部实现</h2> <p>因为</p> <ul><li>子级函数作用域可以直接访问父级函数作用域里的标识符;</li> <li>父级函数作用域不能直接访问子级函数作用域里的标识符.</li></ul> <p>所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。</p> <p>为什么要将代码进行&quot;隐藏&quot;?	
因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p> <p><b>隐藏的好处:</b></p> <ol><li>实现代码私有化,减少外部对内部代码的干扰,保持其稳定性.</li> <li>规避冲突: 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。那么一般规避冲突的手段有哪些?</li></ol> <ul><li><p>全局命名空间: 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。</p></li> <li><p>模块管理: 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd,commonjs,import模块机制.</p></li></ul> <h2 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h2> <p>函数声明与函数表达式:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
	...
}
</code></pre></div><p>我们知道函数foo内的变量和函数被隐藏起来了,是不会对全局作用域造成污染.但是变量名foo仍然存在于全局作用域中,会造成污染.那有什么方法能避免函数名的污染呢?那就是作为函数表达式,而不是一个标准的函数声明.这样函数名只存在于它自己的函数作用域内,而不会存在于其父作用域,这样就没有了污染.举个函数声明的例子:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
  <span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 3 </span>
})(); 
  <span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 2</span>
</code></pre></div><p>当我们用()包裹一个函数,并立即执行.此时这个包装函数声明是从(function开始的而不是从function关键字开始.这样foo就会被当做一个函数表达式,而不是一个函数声明(即foo不会存在于父级作用域中).回到上面的例子中,全局作用域是访问不到foo的,foo只存在于它自己的函数作用域中.</p> <p><b>补充: 什么是函数声明和函数表达式</b>
首先我们得了解JS声明函数的三种方式:</p> <ul><li>函数表达式(Function Expression): 将函数定义为表达式语句（通常是变量赋值,也可以是自调用形式）的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名,因此常被用作匿名函数.如果有,其函数名也只存在自身的函数作用域.并且函数表达式不能以“function”开头.函数表达式可以存储在变量或者对象属性里. (在函数声明前加上运算符是可以将其转化为函数表达式的.例如!,+,-,().举个例子:!function(){console.log(1)}()的结果是1,并不会报错)</li> <li>函数声明(Function Declaration):  函数声明是一种独立的结构,它会声明一个具名函数,并必须以function开头. 且函数声明会进行函数提升.使它能在其所在作用域的任意位置被调用,即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性.</li> <li>Function()构造器: 即使用Function构造器创建函数.不推荐这种用法, 容易出问题</li></ul> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-comment">//Function()构造器</span>
<span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()

<span class="hljs-comment">// 函数表达式</span>
<span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);  
}

<span class="hljs-comment">// 函数声明</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
}

<span class="hljs-built_in">console</span>.log(f())
<span class="hljs-comment">//思考一下,这里会打印出什么</span>
</code></pre></div><p><b>怎么区分函数声明和函数表达式:</b>
看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。例如上例中,是从(开始而不是function.</p> <h3 id="匿名和具名"><a href="#匿名和具名" class="header-anchor">#</a> 匿名和具名</h3> <p>函数表达式可以是匿名的，而函数声明则不可以省略函数名.有函数名的就是具名函数,没有函数名的就是匿名函数.
匿名函数的缺点:</p> <ul><li><p>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p></li> <li><p>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</p></li> <li><p>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</p></li></ul> <p>所以给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践.</p> <h3 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="header-anchor">#</a> 立即执行函数表达式</h3> <p>比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式,也被称为IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression);
IIFE可以具名也可以匿名.好处和上面提到的一样.IIFE还可以是这种形式(function(){ .. }()).这两种形式在功能上是一致的。</p> <h2 id="块作用域"><a href="#块作用域" class="header-anchor">#</a> 块作用域</h2> <p>函数作用域是JavaScript最常见的作用域单元,有时我们仅会将var赋值变量在if或for的{...}内使用,而不会在其他地方使用.但它仍然会对外层的函数作用域造成污染.这个时候就会希望能有一个作用域能将其外部的函数作用域隔开,声明的变量仅在此作用域有效.块作用域(通常就是{...}包裹的内部)就可以帮我们做到这点.</p> <p>从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。</p> <h3 id="with"><a href="#with" class="header-anchor">#</a> with</h3> <p>我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。</p> <h3 id="try-catch"><a href="#try-catch" class="header-anchor">#</a> try/catch</h3> <p>try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">try</span> {
  <span class="hljs-literal">undefined</span>(); <span class="hljs-comment">// 执行一个非法操作来强制制造一个异常</span>
}
<span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-built_in">console</span>.log( err ); <span class="hljs-comment">// 能够正常执行! </span>
}
<span class="hljs-built_in">console</span>.log( err ); <span class="hljs-comment">// ReferenceError: err not found</span>
</code></pre></div><p>err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。	
那么如果我们想用catch创建一个不是仅仅接收err的块作用域,该怎么做呢?</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">try</span>{<span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;}<span class="hljs-keyword">catch</span>(a){ 
  <span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 2</span>
}
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// ReferenceError</span>
</code></pre></div><p>这样就创建了一个块作用域,且 a = 2 ,仅在catch分句中存在.在ES6之前我们可以使用这种方法来使用块作用域.</p> <h3 id="let"><a href="#let" class="header-anchor">#</a> let</h3> <p>ES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。</p> <p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。例如在if的{...}内用let声明一个变量.那什么是显式地创建块作用域呢?就是单独创建{}来作为let的块作用域.而不是借用if或者for提供的{}.例如<code>{let a=2;console.log(a)}</code>
注意: 使用 let 进行的声明不会在块作用域中进行提升.</p> <p>块作用域的好处:</p> <ol><li>垃圾收集</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">data</span>)</span>{
  <span class="hljs-comment">// 在这里做点有趣的事情</span>
}
<span class="hljs-keyword">var</span> someReallyBigData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// dosomeing</span>
}
process(someReallyBigData);

<span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;my_button&quot;</span>);
btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">click</span>(<span class="hljs-params">evt</span>)</span>{
  alert(<span class="hljs-string">&quot;button click&quot;</span>);
<span class="hljs-comment">//假如我们在这里继续调用someReallyBigData就会形成闭包,导致不能垃圾回收(这段是书里没有,我加上方便理解的)</span>
},<span class="hljs-literal">false</span>);
</code></pre></div><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。	
但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">data</span>)</span>{
       <span class="hljs-comment">// 在这里做点有趣的事情</span>
    }
    <span class="hljs-comment">// 在这个块中定义的内容可以销毁了! </span>
    {
      <span class="hljs-keyword">let</span> someReallyBigData = { .. }; 
      process( someReallyBigData );
    }
    <span class="hljs-keyword">var</span> btn=<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;my_button&quot;</span>);
    btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">click</span>(<span class="hljs-params">evt</span>)</span>{
       alert(<span class="hljs-string">&quot;button click&quot;</span>);
    },<span class="hljs-literal">false</span>);
</code></pre></div><ol start="2"><li>let循环</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) { 
	  <span class="hljs-built_in">console</span>.log( i );
     }
<span class="hljs-built_in">console</span>.log( i ); <span class="hljs-comment">// ReferenceError</span>
</code></pre></div><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染.</p> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">if</span> (foo) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">// 包含在 if 中的块作用域常量</span>
  a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 正常!</span>
  b = <span class="hljs-number">4</span>; <span class="hljs-comment">// 错误! </span>
}
<span class="hljs-built_in">console</span>.log( a ); <span class="hljs-comment">// 3</span>
<span class="hljs-built_in">console</span>.log( b ); <span class="hljs-comment">// ReferenceError!</span>
</code></pre></div><h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开.<br>
但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域.</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/readBook/你不知道的JavaScript1/词法作用域.html" class="prev">
        词法作用域
      </a></span> <span class="next"><a href="/readBook/你不知道的JavaScript1/提升.html">
        提升
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.94455cae.js" defer></script><script src="/assets/js/3.46e2d97a.js" defer></script><script src="/assets/js/72.48c072b5.js" defer></script>
  </body>
</html>
