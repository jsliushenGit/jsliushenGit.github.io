<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>启示 | 静水流深</title>
    <meta name="description" content="因上努力 果上随缘">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.54626788.css" as="style"><link rel="preload" href="/assets/js/app.94455cae.js" as="script"><link rel="preload" href="/assets/js/3.46e2d97a.js" as="script"><link rel="preload" href="/assets/js/70.38be5e94.js" as="script"><link rel="prefetch" href="/assets/js/1.31cf2ec8.js"><link rel="prefetch" href="/assets/js/10.1b115c18.js"><link rel="prefetch" href="/assets/js/100.48ac91c6.js"><link rel="prefetch" href="/assets/js/101.d6ebf40b.js"><link rel="prefetch" href="/assets/js/102.d51b5998.js"><link rel="prefetch" href="/assets/js/103.dacdae82.js"><link rel="prefetch" href="/assets/js/104.eaafbc6b.js"><link rel="prefetch" href="/assets/js/105.387bcd14.js"><link rel="prefetch" href="/assets/js/106.7aadd79d.js"><link rel="prefetch" href="/assets/js/107.fa96ea52.js"><link rel="prefetch" href="/assets/js/108.2ac2e870.js"><link rel="prefetch" href="/assets/js/109.003466c2.js"><link rel="prefetch" href="/assets/js/11.36aed0a1.js"><link rel="prefetch" href="/assets/js/110.7b785169.js"><link rel="prefetch" href="/assets/js/111.aa26d5a8.js"><link rel="prefetch" href="/assets/js/112.a4f7a2af.js"><link rel="prefetch" href="/assets/js/113.58f60ffb.js"><link rel="prefetch" href="/assets/js/114.5f4f3292.js"><link rel="prefetch" href="/assets/js/115.6e608edf.js"><link rel="prefetch" href="/assets/js/116.c3f52f15.js"><link rel="prefetch" href="/assets/js/117.d0f1ee75.js"><link rel="prefetch" href="/assets/js/118.0d02556b.js"><link rel="prefetch" href="/assets/js/119.3be8cf42.js"><link rel="prefetch" href="/assets/js/12.b069f455.js"><link rel="prefetch" href="/assets/js/120.71898050.js"><link rel="prefetch" href="/assets/js/121.e683102c.js"><link rel="prefetch" href="/assets/js/122.3870a1bc.js"><link rel="prefetch" href="/assets/js/123.b6709d56.js"><link rel="prefetch" href="/assets/js/124.4056a7fc.js"><link rel="prefetch" href="/assets/js/125.05c0cff6.js"><link rel="prefetch" href="/assets/js/126.bbcde9c3.js"><link rel="prefetch" href="/assets/js/127.f78e81b9.js"><link rel="prefetch" href="/assets/js/128.59121021.js"><link rel="prefetch" href="/assets/js/129.daaddb18.js"><link rel="prefetch" href="/assets/js/13.2a546bf0.js"><link rel="prefetch" href="/assets/js/130.00f0a837.js"><link rel="prefetch" href="/assets/js/131.563da5dc.js"><link rel="prefetch" href="/assets/js/132.43e9a8e5.js"><link rel="prefetch" href="/assets/js/133.65b7f714.js"><link rel="prefetch" href="/assets/js/134.2f0de0be.js"><link rel="prefetch" href="/assets/js/135.cb3bfd28.js"><link rel="prefetch" href="/assets/js/136.54e69925.js"><link rel="prefetch" href="/assets/js/137.3becf6c6.js"><link rel="prefetch" href="/assets/js/138.d8fcc8fe.js"><link rel="prefetch" href="/assets/js/14.aee2ba7b.js"><link rel="prefetch" href="/assets/js/15.5d899dd9.js"><link rel="prefetch" href="/assets/js/16.0f1c1851.js"><link rel="prefetch" href="/assets/js/17.a673a300.js"><link rel="prefetch" href="/assets/js/18.1f5949af.js"><link rel="prefetch" href="/assets/js/19.1216bbbd.js"><link rel="prefetch" href="/assets/js/20.3fc002f0.js"><link rel="prefetch" href="/assets/js/21.65c965a2.js"><link rel="prefetch" href="/assets/js/22.137ca28e.js"><link rel="prefetch" href="/assets/js/23.c459748a.js"><link rel="prefetch" href="/assets/js/24.364abb0a.js"><link rel="prefetch" href="/assets/js/25.25effd1b.js"><link rel="prefetch" href="/assets/js/26.a1d2675a.js"><link rel="prefetch" href="/assets/js/27.0be08613.js"><link rel="prefetch" href="/assets/js/28.70b8c17a.js"><link rel="prefetch" href="/assets/js/29.5adbd5e0.js"><link rel="prefetch" href="/assets/js/30.3843d933.js"><link rel="prefetch" href="/assets/js/31.b27ef3b1.js"><link rel="prefetch" href="/assets/js/32.fdbfc04d.js"><link rel="prefetch" href="/assets/js/33.7760da0f.js"><link rel="prefetch" href="/assets/js/34.437c690e.js"><link rel="prefetch" href="/assets/js/35.796574c9.js"><link rel="prefetch" href="/assets/js/36.0143110b.js"><link rel="prefetch" href="/assets/js/37.c0f92ebc.js"><link rel="prefetch" href="/assets/js/38.440d779f.js"><link rel="prefetch" href="/assets/js/39.969331f9.js"><link rel="prefetch" href="/assets/js/4.a318d046.js"><link rel="prefetch" href="/assets/js/40.194e12d5.js"><link rel="prefetch" href="/assets/js/41.3aac45e7.js"><link rel="prefetch" href="/assets/js/42.713db659.js"><link rel="prefetch" href="/assets/js/43.661ebb12.js"><link rel="prefetch" href="/assets/js/44.ec30c897.js"><link rel="prefetch" href="/assets/js/45.4eb712a2.js"><link rel="prefetch" href="/assets/js/46.b6a1b6c9.js"><link rel="prefetch" href="/assets/js/47.c1446395.js"><link rel="prefetch" href="/assets/js/48.c3cc0d04.js"><link rel="prefetch" href="/assets/js/49.58315dcf.js"><link rel="prefetch" href="/assets/js/5.c09621b5.js"><link rel="prefetch" href="/assets/js/50.9e53e77d.js"><link rel="prefetch" href="/assets/js/51.ec3fb7fc.js"><link rel="prefetch" href="/assets/js/52.f7798353.js"><link rel="prefetch" href="/assets/js/53.0e122f54.js"><link rel="prefetch" href="/assets/js/54.bf2cee05.js"><link rel="prefetch" href="/assets/js/55.c3e2dfb7.js"><link rel="prefetch" href="/assets/js/56.6c5ef542.js"><link rel="prefetch" href="/assets/js/57.97c73bf7.js"><link rel="prefetch" href="/assets/js/58.60793109.js"><link rel="prefetch" href="/assets/js/59.6d8d7ad9.js"><link rel="prefetch" href="/assets/js/6.816c4684.js"><link rel="prefetch" href="/assets/js/60.f30a98a7.js"><link rel="prefetch" href="/assets/js/61.16448d3e.js"><link rel="prefetch" href="/assets/js/62.1bfa5629.js"><link rel="prefetch" href="/assets/js/63.4097bfd8.js"><link rel="prefetch" href="/assets/js/64.e1c5e297.js"><link rel="prefetch" href="/assets/js/65.0712ea96.js"><link rel="prefetch" href="/assets/js/66.f2890611.js"><link rel="prefetch" href="/assets/js/67.8a17f3d4.js"><link rel="prefetch" href="/assets/js/68.985efa4e.js"><link rel="prefetch" href="/assets/js/69.752baca0.js"><link rel="prefetch" href="/assets/js/7.9d533feb.js"><link rel="prefetch" href="/assets/js/71.b1f8bb9d.js"><link rel="prefetch" href="/assets/js/72.48c072b5.js"><link rel="prefetch" href="/assets/js/73.23b44a71.js"><link rel="prefetch" href="/assets/js/74.0eee8813.js"><link rel="prefetch" href="/assets/js/75.d38a3d70.js"><link rel="prefetch" href="/assets/js/76.0c2c5d89.js"><link rel="prefetch" href="/assets/js/77.8cefe9be.js"><link rel="prefetch" href="/assets/js/78.070d2300.js"><link rel="prefetch" href="/assets/js/79.dfb36280.js"><link rel="prefetch" href="/assets/js/8.4433540c.js"><link rel="prefetch" href="/assets/js/80.e0e91da2.js"><link rel="prefetch" href="/assets/js/81.3494411f.js"><link rel="prefetch" href="/assets/js/82.3ece83c0.js"><link rel="prefetch" href="/assets/js/83.570c41b1.js"><link rel="prefetch" href="/assets/js/84.050c5052.js"><link rel="prefetch" href="/assets/js/85.0c6b55a8.js"><link rel="prefetch" href="/assets/js/86.6d7ee4ed.js"><link rel="prefetch" href="/assets/js/87.b051a4a6.js"><link rel="prefetch" href="/assets/js/88.5dbe0bf0.js"><link rel="prefetch" href="/assets/js/89.f33d7730.js"><link rel="prefetch" href="/assets/js/9.9a910bbd.js"><link rel="prefetch" href="/assets/js/90.08da77aa.js"><link rel="prefetch" href="/assets/js/91.35c67dac.js"><link rel="prefetch" href="/assets/js/92.bf002ee6.js"><link rel="prefetch" href="/assets/js/93.b1f55944.js"><link rel="prefetch" href="/assets/js/94.a6109a30.js"><link rel="prefetch" href="/assets/js/95.ae932d48.js"><link rel="prefetch" href="/assets/js/96.210d3793.js"><link rel="prefetch" href="/assets/js/97.ae6e9e5a.js"><link rel="prefetch" href="/assets/js/98.d7a25915.js"><link rel="prefetch" href="/assets/js/99.26da5087.js">
    <link rel="stylesheet" href="/assets/css/0.styles.54626788.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">静水流深</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/readBook/" class="nav-link router-link-active">
  读书笔记
</a></div><div class="nav-item"><a href="/leetcode/" class="nav-link">
  leetcode记录
</a></div><div class="nav-item"><a href="/project/" class="nav-link">
  项目
</a></div><div class="nav-item"><a href="/repository/" class="nav-link">
  知识库
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/readBook/你不知道的JavaScript1/作用域是什么.html" class="sidebar-link">作用域是什么</a></li><li><a href="/readBook/你不知道的JavaScript1/词法作用域.html" class="sidebar-link">词法作用域</a></li><li><a href="/readBook/你不知道的JavaScript1/函数作用域和块作用域.html" class="sidebar-link">函数作用域和块作用域</a></li><li><a href="/readBook/你不知道的JavaScript1/提升.html" class="sidebar-link">提升</a></li><li><a href="/readBook/你不知道的JavaScript1/作用域闭包.html" class="active sidebar-link">作用域闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#启示" class="sidebar-link">启示</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#实质问题" class="sidebar-link">实质问题</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#循环和闭包" class="sidebar-link">循环和闭包</a></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#模块" class="sidebar-link">模块</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#现代的模块机制" class="sidebar-link">现代的模块机制</a></li></ul></li><li class="sidebar-sub-header"><a href="/readBook/你不知道的JavaScript1/作用域闭包.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/readBook/你不知道的JavaScript1/关于this.html" class="sidebar-link">关于this</a></li><li><a href="/readBook/你不知道的JavaScript1/this全面解析.html" class="sidebar-link">this全面解析</a></li><li><a href="/readBook/你不知道的JavaScript1/对象.html" class="sidebar-link">对象</a></li><li><a href="/readBook/你不知道的JavaScript1/混合对象类.html" class="sidebar-link">混合对象&quot;类&quot;</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="启示"><a href="#启示" class="header-anchor">#</a> 启示</h2> <ul><li>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</li> <li>闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。</li></ul> <h2 id="实质问题"><a href="#实质问题" class="header-anchor">#</a> 实质问题</h2> <p>什么是闭包?(广义版)<br>
书中解释: 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。<br>
MDN的解释: 闭包是函数和声明该函数的词法环境的组合。<br>
我的解释(详细版): 必须包含两点:</p> <p>1,有函数.由于函数自身的特性,它能访问所在的词法作用域.并能保存外部词法作用域的变量和函数到自己的函数作用域.
2,有该函数所在的词法环境.其实在JavaScript中任何函数都会处在一个词法环境中.不管是全局作用域还是函数作用域.</p> <p>综上简单版就是: MDN的解释 -- 闭包是函数和声明该函数的词法环境的组合。</p> <p>还可以继续延伸成极简版: JavaScript中的函数就会形成闭包。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注意到上面对词法作用域和词法环境两词的分开使用了吗?</p> <ol><li>此时函数还没被执行,所以使用的是词法作用域即静态作用域</li> <li>此时函数被执行,此时词法作用域就会变成词法环境(包含静态作用域与动态作用域).所以其实MDN的解释其实更准确一点</li></ol></div> <p>我们日常使用时所说的闭包(狭义版,严格意义上的):</p> <p>为了便于对闭包作用域的观察和使用.我们实际使用时会将闭包的函数作用域暴露给当前词法作用域之外.也就是本书一直强调的闭包函数需要在它本身的词法作用域以外执行.作者认为符合这个条件才称得上是真正的闭包(也就是我们日常使用常说的'使用闭包',并且使用任何回调函数其实也是闭包).</p> <p>所以狭义版就是:闭包是函数和声明该函数的词法环境的组合,并且将闭包的函数作用域暴露给当前词法作用域之外.</p> <p>闭包暴露函数作用域的三种方式:
下面部分是书中没有的,是自己实际使用时的总结,并且符合这三种形式之一的就是我们日常使用时所说的闭包(狭义版)</p> <ol><li>通过外部函数的参数进行暴露.</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ 
   baz(a) <span class="hljs-comment">//通过外部函数的参数进行暴露</span>
  }
  bar(); 
};
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params">val</span>) </span>{ 
  <span class="hljs-built_in">console</span>.log( val ); <span class="hljs-comment">// 2 </span>
}
foo();
</code></pre></div><ol start="2"><li>通过外部作用域的变量进行暴露</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">var</span> val;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ 
   val=a <span class="hljs-comment">//通过外部作用域的变量进行暴露</span>
  }
  bar(); 
};
foo();
<span class="hljs-built_in">console</span>.log(val)  <span class="hljs-comment">//2</span>
</code></pre></div><ol start="3"><li>通过return直接将整个函数进行暴露</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-built_in">console</span>.log(a)
  }
  <span class="hljs-keyword">return</span> bar <span class="hljs-comment">//通过return直接将整个函数进行暴露</span>
};
<span class="hljs-keyword">var</span> val=foo();
val()  <span class="hljs-comment">//2</span>
</code></pre></div><p>关于闭包的内存泄露问题:</p> <p>首先必须声明一点: 使用闭包并不一定会造成内存泄露,只有使用闭包不当才可能会造成内存泄露.(吐槽:面试很多新人时,张口就说闭包会造成内存泄露)</p> <p>为什么闭包可能会造成内存泄露呢? 原因就是上面提到的,因为它一般会暴露自身的作用域给外部使用.如果使用不当,就可能导致该内存一直被占用,无法被JS的垃圾回收机制回收.就造成了内存泄露.
注意: 即使闭包里面什么都没有,闭包仍然会隐式地引用它所在作用域里的所用变量.   正因为这个隐藏的特点,闭包经常会发生不易发现的内存泄漏问题.</p> <p>常见哪些情况使用闭包会造成内存泄露:</p> <ol><li>使用定时器未及时清除.因为计时器只有先停止才会被回收.所以决办法很简单,将定时器及时清除,并将造成内存的变量赋值为null(变成空指针)</li> <li>相互循环引用.这是经常容易犯的错误,并且也不容易发现.举个栗子:</li></ol> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{ 
  <span class="hljs-keyword">var</span> a = {}; 
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-built_in">console</span>.log(a); 
  }; 
  a.fn = bar; 
  <span class="hljs-keyword">return</span> bar; 
};
</code></pre></div><p>这里创建了一个a 的对象，该对象被内部函数bar引用。然后，a创建了一个属性fn指向了bar，最后返回了innerFn()。这样就形成了bar和a的相互循环引用.可能有人说bar里不使用console.log(a)不就没有引用了吗就不会造成内存泄露了.NONONO,bar作为一个闭包,即使它内部什么都没有,foo中的所有变量都还是隐使地被 bar所引用。这个知识点是我前面忘记提到的,也是书中没有提到的.算了我现在加到前面去吧.所以即使bar内什么都没有还是造成了循环引用,那真正的解决办法就是,不要将 <code>a.fn = bar</code></p> <ol start="3"><li>将闭包引用到全局变量上.因为全局变量是只有当页面被关闭的时候才会被回收.</li> <li>在闭包中对DOM进行不当的引用.这个常见于老IE浏览器,现代浏览器已经长大了,已经学会了自己处理这种情况了.这里就不赘述了.想知道的可以自行问谷娘和度娘.</li></ol> <p>总而言之,解决办法就是使闭包的能正常引用,能被正常回收.如果实在不行,就是在使用完后,手动将变量赋值null,强行进行垃圾回收.</p> <h2 id="循环和闭包"><a href="#循环和闭包" class="header-anchor">#</a> 循环和闭包</h2> <p>看如下例子:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) { 
  setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( i );
  }, i*<span class="hljs-number">1000</span> );
}
</code></pre></div><p>我们期望的结果是分别输出数字 1~5，每秒一次，每次一个。<br>
但实际结果是,这段代码在运行时会以每秒一次的频率输出五次 6。<br>
(关于书里的解释,我觉得有点说复杂了,没说到点子上,下面是我的解释.)</p> <p>为什么会是这样的结果?</p> <p>timer毫无疑问是一个闭包,它是可以访问到外部的变量i.在进行for循环时,timer()会被重复执行5次,也就是它会 console.log( i )5次.(关键部分来了!)这5次i其实是同一个i.它是来自于外部作用域,即for里面声明的i.在词法作用域中变量i只可能对应一个唯一的值,即变量和它的值是一一对应的.不会变化的.那这个值到底是多少呢?这个值就是最终值! i的最终值就是6即for循环完后i的值.当引擎执行console.log( i )时,它会询问i所对应的作用域,问它i的值是多少.这个时候作用域进行RHS查询得到的结果就是最终值6.</p> <p>为什么我们会以为分别输出1~5?</p> <p>因为在for循环中,我们错以为每一次循环时,函数所输出的i是根据循环动态变化的.即是1~5累加变化的.但实际上它所访问的i是同一个固定不变的值,即最终值6.可能你会有这样的疑惑,那我循环还有意义吗?i其实一开始就确定是6了.没有变化过!错!i变化过,它的确是从1逐步增加到6的.只是外部作用域的i值只可能是循环完后的最终值,并且函数timer()并没有保存每次i变化的值.它只是访问了外部作用域的i值即最终的值6. OK我们知道了出错的地方,就是我们没有把每次i的值保存在一个独立的作用域中.
接下来,看下这个改进的例子结果是多少.</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) { 
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{ 
	    <span class="hljs-built_in">console</span>.log( i );
    }, i*<span class="hljs-number">1000</span> );
  })();
}
</code></pre></div><p>它的最终值仍然是5个6.为什么?我们来分析下,上例中,它用了一个匿名函数包裹了定时器,并立即执行.在进行for循环时,会创造5个独立的函数作用域(由匿名函数创建的,因为它是闭包函数).但是这5个独立的函数作用域里的i也全都是对外部作用域的引用.即它们访问的都是i的最终值6.这并不是我们想要的,我们要的是5个独立的作用域,并且每个作用域都保存一个&quot;当时&quot;i的值.</p> <p>解决办法:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) { 
  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> j =i;
    setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{ 
	    <span class="hljs-built_in">console</span>.log( j );
    }, j*<span class="hljs-number">1000</span> );
  })();
}
</code></pre></div><p>这样改写后,匿名函数每次都通过j保存了每次i值,这样i值就通过j保存在了独立的作用域中.注意此时保存的i值是'当时'的值,并不是循环完后的最终值.这样循环完后,实际上就创建了5个独立的作用域,每个作用域都保存了一个'当时'i的值(通过j).当引擎执行console.log( j )询问其对应的独立作用域时,得到的值就是'当时'保存的值,再也不是6了.</p> <p>我们还可以进一步简写为这样:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) { 
  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) </span>{
    setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{ 
      <span class="hljs-built_in">console</span>.log( j );
    }, j*<span class="hljs-number">1000</span> );
  })(i);
}
</code></pre></div><p>利用块作用域进行解决:<br>
在es6中,我们不仅可以使用函数来创建一个独立的作用域,我们还可以使用let声明来创建一个独立的块作用域(在{}内).所以我们还可以这样改写:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++) { 
  setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( i );
  }, i*<span class="hljs-number">1000</span> );
}
</code></pre></div><p>这样改写,在每次循环时,let都会对i进行声明.并通过循环自带的{}创建一个独立的块作用域.并且let声明的i,保存了'当时'i的值在当前块作用域里.因此当引擎执行console.log( i )时,它会询问对应的块作用域上i的值,得到的结果就是'当时'保存的值.</p> <h2 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h2> <p>首先看下面的例子:</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CoolModule</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> something = <span class="hljs-string">&quot;cool&quot;</span>;
  <span class="hljs-keyword">var</span> another = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>{ 
    <span class="hljs-built_in">console</span>.log( something );
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAnother</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log( another.join( <span class="hljs-string">&quot; ! &quot;</span> ) );
  }
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">doSomething</span>: doSomething,
	  <span class="hljs-attr">doAnother</span>: doAnother
  }; 
}
<span class="hljs-keyword">var</span> foo = CoolModule(); 

foo.doSomething(); <span class="hljs-comment">// cool</span>
foo.doAnother(); <span class="hljs-comment">// 1 ! 2 ! 3</span>
</code></pre></div><p>首先我们对上面这段代码进成分行分析:
私有数据变量: something, another<br>
内部函数: doSomething, doAnother<br>
直接说结论,上面这个例子就是模块模式.它return返回的这个对象也就是模块也被称为公共API(至少书中是这样称呼的).CoolModule()就是模块构造器或者叫模块函数.</p> <p>注意:</p> <ul><li>这里的模块和我们所说的模块化开发不是完全一样的!</li> <li>模块不一定非要是标准对象,也可以是一个函数,函数本质上也是对象,函数也可以有自己的属性.</li> <li>书中有这样一句话CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。我觉得这句话有必要延伸说一下.函数调用一次就会创建一个该函数的作用域(不调用就不会创建),包括创建它里面的变量和函数.</li></ul> <p>模块模式:</p> <p>模块模式需要具备以下2个条件:(这里结合上面的例子,对书中的定义进行说明方便理解)</p> <ol><li>必须有外部的封闭函数(即CoolModule)，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例--&gt;模块实例指的就是函数return返回的对象)。</li> <li>封闭函数(即CoolModule)必须返回至少一个内部函数(即doSomething, doAnother)，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态(即something, another)。</li></ol> <p>模块:</p> <p>表面上看由模块函数(例子中的CoolModule)所返回的对象就是模块.但模块还必须还包含模块函数的内部函数(即闭包函数).只有包含了才能真正称得上是模块.才强调一次这里的模块与模块化里的模块是有区别的,也不是nodejs里的模块.</p> <p>模块函数:<br>
模块函数也就是模块构造器,例子中的CoolModule().一般它有两个常见用法.</p> <ul><li>通过接受参数,对输出的模块进行修改.</li> <li>通过添加模块里添加相关的内部函数,实现对输出模块数据的增删改查.(书中用命名将要作为公共API返回的对象.我觉得命名应该是用错了,应该是修改即增删改查更好)</li></ul> <h3 id="现代的模块机制"><a href="#现代的模块机制" class="header-anchor">#</a> 现代的模块机制</h3> <p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。
下面就介绍一个简单的模块管理器实现例子(对书中的例子进行逐行解读):</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript"><span class="hljs-comment">//首先实例化我们的模块管理器,取名myModules</span>
<span class="hljs-keyword">var</span> MyModules=(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Manager</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//作为我们的模块池,保存所有定义的模块</span>
  <span class="hljs-keyword">var</span> modules={};

  <span class="hljs-comment">/**
   *使用类似AMD的方式定义新模块，接收3个参数
    *name:模块名
    *deps:数组形式表示所依赖的其他模块
    *impl:模块功能的实现
  **/</span> 
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">define</span>(<span class="hljs-params">name,deps,impl</span>) </span>{
    <span class="hljs-comment">//遍历依赖模块数组的每一项，从程序池中取出对应的模块,并赋值.</span>
    <span class="hljs-comment">//循环完后,deps由保存模块名的数组变成了保存对应模块的数组.</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;deps.length;i++) {
      deps[i]=modules[deps[i]];
    }
    <span class="hljs-comment">//将新模块存储进模块池，并通过apply注入它所依赖的模块(即遍历后的deps,实际上就是用deps作为impl的入参)</span>
    modules[name]=impl.apply(impl,deps);
  }
  <span class="hljs-comment">//从模块池中取出对应模块</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> modules[name];
  }
  <span class="hljs-comment">//暴露定义模块和获取模块的两个api</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">define</span>: define,
    <span class="hljs-attr">get</span>: <span class="hljs-keyword">get</span>
  }
})()
</code></pre></div><p>说明:  后面书中说了这么一句<code>为了模块的定义引入了包装函数(可以传入任何依赖)</code>,这里包装函数指的是Manger(),同样也是我们上节提到的模块函数.首先说明下什么是包装函数.例如函数A当中还有一个函数B.当我们想要调用函数B的时候,则需要先调用函数A.那么函数A就叫做函数B的包装函数.也就是说我们想调用某个模块时,需要先调用它的包装函数即这里的Manger().接着是后面那句并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。注意这里的返回值是指impl的返回值.</p> <p>接着看通过管理器来定义和使用模块</p> <div class="language-JavaScript extra-class"><pre><code class="language-JavaScript">MyModules.define(<span class="hljs-string">'bar'</span>,[],<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span> (<span class="hljs-params">who</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Let me introduce: &quot;</span> + who;
  }
	<span class="hljs-comment">//返回公共API 即提供一个hello的接口</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">hello</span>:hello
  };
});

MyModules.define(<span class="hljs-string">'foo'</span>,[<span class="hljs-string">'bar'</span>],<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bar</span>) </span>{
  <span class="hljs-keyword">var</span> hungry = <span class="hljs-string">&quot;hippo&quot;</span>;

  functin awesome () {
  <span class="hljs-comment">//这里的bar为返回模块bar返回的公共API</span>
      <span class="hljs-built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );
  }
  <span class="hljs-comment">//返回公共API 即提供一个awesome的接口</span>
  <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">awesome</span>:awesome
  }
})

<span class="hljs-keyword">var</span> bar = MyModules.get(<span class="hljs-string">'bar'</span>);<span class="hljs-comment">//通过管理器获取模块'bar'</span>
<span class="hljs-keyword">var</span> foo = MyModules.get(<span class="hljs-string">'foo'</span>);<span class="hljs-comment">//通过管理器获取模块'foo'</span>

<span class="hljs-built_in">console</span>.log(
  <span class="hljs-comment">//调用模块bar的hello接口</span>
  bar.hello( <span class="hljs-string">&quot;hippo&quot;</span> ) 
); <span class="hljs-comment">// Let me introduce: hippo </span>

<span class="hljs-comment">//调用模块foo的awesome接口</span>
foo.awesome(); <span class="hljs-comment">// LET ME INTRODUCE: HIPPO</span>
</code></pre></div><p>这节的主要内容还是了解现在是如何对模块进行一个规范处理.主要是两部分内容,一个是通过名称和依赖合理定义模块并储存.另一个则是通过名称对存储的模块的调用.其实还可以再增加一个删除模块的方法.</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>闭包:当函数可以记住并访问所在的词法作用域，并且函数是在当前词法作用域之外执行，这时 就产生了闭包。
模块有两个主要特征:</p> <ul><li>为创建内部作用域而调用了一个包装函数(模块构造器的实例化,不想对频繁换名字吐槽了);</li> <li>包装函数的返回值(也就是模块)必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/readBook/你不知道的JavaScript1/提升.html" class="prev">
        提升
      </a></span> <span class="next"><a href="/readBook/你不知道的JavaScript1/关于this.html">
        关于this
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.94455cae.js" defer></script><script src="/assets/js/3.46e2d97a.js" defer></script><script src="/assets/js/70.38be5e94.js" defer></script>
  </body>
</html>
