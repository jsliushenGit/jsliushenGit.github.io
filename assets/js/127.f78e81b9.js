(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{333:function(e,n,t){"use strict";t.r(n);var a=t(16),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("title: webpack4原理及简单实现（二）-- AST\nauthor: jsliushen\ntags:")]),e._v(" "),t("ul",[t("li",[e._v("webpack\ncategories:")]),e._v(" "),t("li",[e._v("前端\ndate: 2019-04-14 16:43:00")])]),e._v(" "),t("hr"),e._v(" "),t("p",[e._v("webpack使用各种loader来编译模块，那么具体的编译是怎么实现的呢。这时候就轮到主角AST--抽象语法树登场了。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。\n")])])]),t("p",[e._v("这棵树定义了代码本身，通过操作这颗树，可以精准的定位到赋值语句、声明语句和运算语句。对树的节点遍历修改属性，可以帮助我们对代码做各种修改。")]),e._v(" "),t("p",[e._v("AST的使用场景非常广泛，包括代码语法的检查、代码风格的检查、代码的格式化、代码的高亮、代码错误提示、代码自动补全等等。")]),e._v(" "),t("p",[e._v("将javascript源码转换成抽象语法树需要借助引擎，现在常用的引擎有")]),e._v(" "),t("ul",[t("li",[e._v("esprima")]),e._v(" "),t("li",[e._v("acron (webpack使用的)")]),e._v(" "),t("li",[e._v("Traceur")]),e._v(" "),t("li",[e._v("UglifyJS2")]),e._v(" "),t("li",[e._v("shift")])]),e._v(" "),t("p",[e._v("这是在线的AST转换器："),t("a",{attrs:{href:"https://astexplorer.net/",title:"AST转换器",target:"_blank",rel:"noopener noreferrer"}},[e._v("AST转换器"),t("OutboundLink")],1),e._v("。我们使用babylon引擎将代码 "),t("code",[e._v("const a = 1")]),e._v(" 转化成AST后的格式如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('{\n  "type": "Program",\n  "start": 0,\n  "end": 11,\n  "body": [\n    {\n      "type": "VariableDeclaration",\n      "start": 0,\n      "end": 11,\n      "declarations": [\n        {\n          "type": "VariableDeclarator",\n          "start": 6,\n          "end": 11,\n          "id": {\n            "type": "Identifier",\n            "start": 6,\n            "end": 7,\n            "name": "a"\n          },\n          "init": {\n            "type": "Literal",\n            "start": 10,\n            "end": 11,\n            "value": 1,\n            "raw": "1"\n          }\n        }\n      ],\n      "kind": "const"\n    }\n  ],\n  "sourceType": "module"\n}\n')])])]),t("p",[e._v("各字段的说明如下:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('type:描述该语句的类型 --变量声明语句\nkind：变量声明的关键字 -- var\ndeclaration: 声明的内容数组，里面的每一项也是一个对象\n\ttype: 描述该语句的类型 \n\tid: 描述变量名称的对象\n\t\ttype：定义\n\t\tname: 是变量的名字\n    init: 初始化变量值得对象\n\t\ttype: 类型\n\t\tvalue: 值 "is tree" 不带引号\n\t\trow: "\\"is tree"\\" 带引号\n')])])]),t("p",[e._v("AST的使用步骤可以归纳为3步：")]),e._v(" "),t("ol",[t("li",[e._v("通过引擎将代码转换陈AST")]),e._v(" "),t("li",[e._v("遍历和更新AST")]),e._v(" "),t("li",[e._v("将更新之后的AST再转换成代码")])]),e._v(" "),t("p",[e._v("下面我们以acron为例，简单的演示一下AST的应用方式。我们希望把 "),t("code",[e._v("const a = 1")]),e._v(" 这句代码编译成 "),t("code",[e._v("var a = 1")])]),e._v(" "),t("h4",{attrs:{id:"一、通过引擎将代码转换成ast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、通过引擎将代码转换成ast"}},[e._v("#")]),e._v(" 一、通过引擎将代码转换成AST")]),e._v(" "),t("p",[e._v("我们新建一个工程，安装依赖\n"),t("code",[e._v("npm i acorn estraverse escodegen")]),t("br"),e._v("\n写好源码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const acorn = require('acorn')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n\nlet source = 'const a = 1'\n")])])]),t("p",[e._v("通过引擎将代码转换成AST需要调用babylon中的parse方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const acorn = require('acorn')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n\nlet source = 'const a = 1'\n\nconst ast = acorn.parse(source, {\n\tsourceType: \"script\",\n  locations: true\n})\n\nconsole.log(ast)\n")])])]),t("p",[e._v("打印生成的ast，和我们上面通过"),t("a",{attrs:{href:"https://astexplorer.net/",title:"AST转换器",target:"_blank",rel:"noopener noreferrer"}},[e._v("AST转换器"),t("OutboundLink")],1),e._v("转换生成的结果是一样的。这样我们就完成了第一步")]),e._v(" "),t("h4",{attrs:{id:"二、遍历和更新ast"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、遍历和更新ast"}},[e._v("#")]),e._v(" 二、遍历和更新AST")]),e._v(" "),t("p",[e._v("上述代码中引入的traverse就是用来遍历AST的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const acorn = require('acorn')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n\nlet source = 'const a = 1'\n\nconst ast = acorn.parse(source, {\n\tsourceType: \"script\",\n  locations: true\n})\n\nconsole.log(ast)\n\nestraverse.traverse(ast, {\n\tenter(node) {\n    \t// 找到kind为const的node\n\t\tif (node.kind === 'const') {\n        \t// 将kind修改为var\n\t\t\tnode.kind = 'var'\n\t\t}\n\t}\n})\n")])])]),t("h4",{attrs:{id:"三、将更新之后的ast再转换成代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、将更新之后的ast再转换成代码"}},[e._v("#")]),e._v(" 三、将更新之后的AST再转换成代码")]),e._v(" "),t("p",[e._v("AST修改之后，我们需求将它再转换成代码，这一步使用escodegen模块")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("const acorn = require('acorn')\nconst estraverse = require('estraverse')\nconst escodegen = require('escodegen')\n\nlet source = 'const a = 1'\n\nconst ast = acorn.parse(source, {\n\tsourceType: \"script\",\n  locations: true\n})\n\nconsole.log(ast)\n\nestraverse.traverse(ast, {\n\tenter(node) {\n    \t// 找到kind为const的node\n\t\tif (node.kind === 'const') {\n        \t// 将kind修改为var\n\t\t\tnode.kind = 'var'\n\t\t}\n\t}\n})\n\n// 将ast转化成代码\nlet code = escodegen.generate(ast)\n\nconsole.log(code)   // var a = 1\n\n")])])]),t("p",[e._v("经过上面三个步骤，我们成功的将代码进行了修改。webpack中对模块的编译也和上述过程类似，只是代码逻辑更复杂，有兴趣的同学可以对AST深入研究。")])])}),[],!1,null,null,null);n.default=r.exports}}]);