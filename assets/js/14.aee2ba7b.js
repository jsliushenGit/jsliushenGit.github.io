(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{310:function(s,a,t){s.exports=t.p+"assets/img/cfzyy.9b503558.png"},391:function(s,a,t){"use strict";t.r(a);var v=t(16),l=Object(v.a)({},(function(){var s=this,a=s.$createElement,v=s._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("p",[s._v("作用域分为两种工作模式:")]),s._v(" "),v("ol",[v("li",[s._v("词法作用域"),v("br"),s._v("\n目前最为普遍的，被大多数编程语言所采用的模式.当然JavaScript也是使用的词法作用域.")]),s._v(" "),v("li",[s._v("动态作用域"),v("br"),s._v("\n使用较少,比如 Bash 脚本、Perl 中的一些模式等.")])]),s._v(" "),v("h2",{attrs:{id:"词法阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#词法阶段"}},[s._v("#")]),s._v(" 词法阶段")]),s._v(" "),v("p",[s._v("大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("词法作用域")]),s._v(" "),v("p",[s._v("词法作用域就是定义在词法阶段的作用域也被称为静态作用域。即在JavaScript里作用域的产生是在编译器出来的第一阶段词法阶段产生的,并且是你在书写完代码时就已经确定了的.")])]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("词法作用域位置")]),s._v(" "),v("p",[s._v("词法作用域位置范围完全由写代码期间函数所声明的位置来决定.")])]),s._v(" "),v("p",[s._v("理解词法作用域及嵌套:\n看下例子:")]),s._v(" "),v("div",{staticClass:"language-JavaScript extra-class"},[v("pre",[v("code",{staticClass:"language-JavaScript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),v("span",{staticClass:"hljs-params"},[s._v("a")]),s._v(") ")]),s._v("{ \n  "),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b = a * "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n  \n  "),v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("bar")]),s._v("("),v("span",{staticClass:"hljs-params"},[s._v("c")]),s._v(") ")]),s._v("{ \n    "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a, b, c );\n  }\n\n  bar( b * "),v("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(" ); \n}\nfoo( "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" ); "),v("span",{staticClass:"hljs-comment"},[s._v("// 2, 4, 12")]),s._v("\n")])])]),v("p",[s._v('在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们分成3个逐级包含的"气泡作用域"。')]),s._v(" "),v("p",[v("img",{attrs:{src:t(310),alt:""}})]),s._v(" "),v("p",[s._v("1:包含着整个全局作用域，其中只有一个标识符:foo"),v("br"),s._v("\n2:包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b"),v("br"),s._v("\n3:包含着 bar 所创建的作用域，其中只有一个标识符:c")]),s._v(" "),v("p",[s._v("注意: 没有任何函数的气泡可以(部分地)同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。")]),s._v(" "),v("p",[s._v("引擎对作用域的查找:"),v("br"),s._v("\n这一部分在上一节中已经说过,就是从当前作用域逐级向上,直到最上层的全局作用域.这里再进一步进行讲解.作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。")]),s._v(" "),v("p",[s._v("注意:")]),s._v(" "),v("p",[s._v("全局变量会自动成为全局对象(比如浏览器中的 window对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。例如:window.a  通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。\n词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。")]),s._v(" "),v("h2",{attrs:{id:"欺骗词法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#欺骗词法"}},[s._v("#")]),s._v(" 欺骗词法")]),s._v(" "),v("p",[s._v("欺骗词法: 引擎在运行时来“修改”(也可以说欺骗)词法作用域.或者说就是在引擎运行时动态地修改词法作用域(本来在编译词法化就已经确定的).\n欺骗词法的两种机制:(下面这两种机制理解了解即可,不推荐实际开发使用)")]),s._v(" "),v("h3",{attrs:{id:"eval"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eval"}},[s._v("#")]),s._v(" eval")]),s._v(" "),v("p",[s._v("JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即将eval放在该词法作用域,然后eval携带的代码就会动态加入到该词法作用域.\n通过下面的例子加深理解:")]),s._v(" "),v("div",{staticClass:"language-JavaScript extra-class"},[v("pre",[v("code",{staticClass:"language-JavaScript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),v("span",{staticClass:"hljs-params"},[s._v("str, a")]),s._v(") ")]),s._v("{ \n  "),v("span",{staticClass:"hljs-built_in"},[s._v("eval")]),s._v("( str ); "),v("span",{staticClass:"hljs-comment"},[s._v("// 欺骗! ")]),s._v("\n  "),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a, b );\n}\n"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b = "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\nfoo( "),v("span",{staticClass:"hljs-string"},[s._v('"var b = 3;"')]),s._v(", "),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(" ); "),v("span",{staticClass:"hljs-comment"},[s._v("// 1, 3")]),s._v("\n")])])]),v("p",[s._v('eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。')]),s._v(" "),v("p",[v("b",[s._v("注意:")])]),s._v(" "),v("p",[s._v("eval(..) 通常被用来执行动态创建的代码.可以据程序逻辑动态地将变量和函数以字符形式拼接在一起之后传递进去。"),v("br"),s._v("\n在严格模式下,eval(...)无法修改所在的作用域。"),v("br"),s._v("\n与eval(...)类似,setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。"),v("br"),s._v("\nnew Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。")]),s._v(" "),v("div",{staticClass:"language-JavaScript extra-class"},[v("pre",[v("code",{staticClass:"language-JavaScript"},[v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" sum = "),v("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),v("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("("),v("span",{staticClass:"hljs-string"},[s._v('"a"')]),s._v(", "),v("span",{staticClass:"hljs-string"},[s._v('"b"')]),s._v(", "),v("span",{staticClass:"hljs-string"},[s._v('"return a + b;"')]),s._v(");\n"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(sum("),v("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(", "),v("span",{staticClass:"hljs-number"},[s._v("1111")]),s._v("));  "),v("span",{staticClass:"hljs-comment"},[s._v("//1112")]),s._v("\n")])])]),v("h3",{attrs:{id:"with-不推荐实际使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#with-不推荐实际使用"}},[s._v("#")]),s._v(" with(不推荐实际使用)")]),s._v(" "),v("p",[s._v("例子:")]),s._v(" "),v("div",{staticClass:"language-JavaScript extra-class"},[v("pre",[v("code",{staticClass:"language-JavaScript"},[v("span",{staticClass:"hljs-function"},[v("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),v("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),v("span",{staticClass:"hljs-params"},[s._v("obj")]),s._v(") ")]),s._v("{ \n  "),v("span",{staticClass:"hljs-keyword"},[s._v("with")]),s._v(" (obj) {\n    a = "),v("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("; \n  }\n}\n\n"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o1 = {\n  "),v("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),v("span",{staticClass:"hljs-number"},[s._v("3")]),s._v("\n};\n\n"),v("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o2 = { \n  "),v("span",{staticClass:"hljs-attr"},[s._v("b")]),s._v(": "),v("span",{staticClass:"hljs-number"},[s._v("3")]),s._v("\n};\nfoo( o1 );\n"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( o1.a ); "),v("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n\nfoo( o2 );\n"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( o2.a ); "),v("span",{staticClass:"hljs-comment"},[s._v("// undefined")]),s._v("\n"),v("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),v("span",{staticClass:"hljs-comment"},[s._v("// 2——不好，a 被泄漏到全局作用域上了!")]),s._v("\n")])])]),v("p",[s._v("起初你会觉得o1的a属性被with里的a进行了词法引用被遮蔽了成为了2.而o2没有a属性,此时with不能进行词法引用,所以此时o2.a就会变成undefined.但是,为什么最后console.log(a)会为2?因为在执行foo(o2)时,with会对其中的a=2进行LHS查询,但它在o2作用域,foo()作用域,全局作用域都没找到,因此就创建了一个全局变量a并随后赋值2."),v("br"),s._v("\n总的来说,with就是将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。"),v("br"),s._v("\n注意: 使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。")]),s._v(" "),v("h3",{attrs:{id:"性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[s._v("#")]),s._v(" 性能")]),s._v(" "),v("p",[s._v("JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是eval(..) 和 with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这么做就会导致引擎无法知道eval和with它们对词法作用域进行什么样的改动.只能对部分不进行处理和优化!因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢!。")]),s._v(" "),v("h2",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),v("p",[s._v("词法作用域是在你书写代码时就已经决定了的.在编译的第一阶段词法分析阶段产生词法作用域.此时词法作用域基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。\neval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。"),v("br"),s._v("\n一般不要在实际代码中使用eval(...)和with,因为不仅危险,而且会造成性能问题!")])])}),[],!1,null,null,null);a.default=l.exports}}]);