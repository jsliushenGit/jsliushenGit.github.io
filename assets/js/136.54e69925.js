(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{403:function(s,a,t){"use strict";t.r(a);var n=t(16),e=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("title: 'javascript再出发: 模拟promise的实现'\nauthor: jsliushen\ntags:")]),s._v(" "),t("ul",[t("li",[s._v("javascript\ncategories:")]),s._v(" "),t("li",[s._v("技术")]),s._v(" "),t("li",[s._v("''\ndate: 2018-08-27 22:22:00")])]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("根据阮一峰的《ECMAScript6入门》中的介绍")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\n")])])]),t("p",[s._v("现在我们来模拟实现一个Promise类，完成基本的功能和部分API。")]),s._v(" "),t("h2",{attrs:{id:"基本功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本功能"}},[s._v("#")]),s._v(" 基本功能")]),s._v(" "),t("p",[s._v("首先看一下promise的基本用法")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// ... some code")]),s._v("\n\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-comment"},[s._v("/* 异步操作成功 */")]),s._v("){\n    resolve(value);\n  } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n    reject(error);\n  }\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(")=>")]),s._v("{\n\t\n},(error)=>{\n\t\n})\n")])])]),t("p",[s._v("通过上述代码，我们来简单的整理一下我们的基础版本需要实现的功能。")]),s._v(" "),t("ol",[t("li",[s._v("创造一个构造函数或者类，名Promise")]),s._v(" "),t("li",[s._v("实例化Promise对象时要传入一个函数参数fn，fn有两个参数，resolve和reject")]),s._v(" "),t("li",[s._v("实例化时会执行fn，在fn中可以调用resolve和reject并传入参数")]),s._v(" "),t("li",[s._v("这个实例化对象可以调用then方法，then方法中可以传入两个回调函数，分别对应reolve和reject。当fn中调用的是resolve时，会触发then中的第一个回调函数，当fn中调用的是reject时，会调用then中的第二个回调函数。")])]),s._v(" "),t("p",[s._v("下面上代码")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-comment"},[s._v("//创建一个myPromise类")]),s._v("\n"),t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("MyPromsie")])]),s._v("{\n\t"),t("span",{staticClass:"hljs-comment"},[s._v("//传入参数fn")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(fn){\n    \t"),t("span",{staticClass:"hljs-comment"},[s._v("//保存promise中的关键数据，resolve和reject的回调函数及它们的参数")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n        \n        "),t("span",{staticClass:"hljs-comment"},[s._v("//调用resolve时，保存参数，调用对应的回调函数")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resolve = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(")=>")]),s._v("{\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = value\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n        }\n\n\t\t"),t("span",{staticClass:"hljs-comment"},[s._v("//调用reject时，保存参数，调用对应的回调函数")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" reject = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("error")]),s._v(")=>")]),s._v("{\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = error\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n        }\n\n\t\t"),t("span",{staticClass:"hljs-comment"},[s._v("//实例化Promise对象时，执行fn")]),s._v("\n        fn(resolve, reject)\n    }\n    \n    "),t("span",{staticClass:"hljs-comment"},[s._v("//在原型上定义then方法，接收两个回调函数")]),s._v("\n    then(onFulfilled,onRejected){\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = onFulfilled;\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = onRejected\n    }\n}\n")])])]),t("p",[s._v("测试一下")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("new MyPromsie((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve(1)\n        reject(2)\n    },2000)\n}).then((res)=>{\n    console.log(res)\n},(err)=>{\n\tconsole.log(err)\n})\n")])])]),t("p",[s._v("以上代码会在2秒后打印出1，2\n不考虑其他功能，我们算是实现了上面的4个需求，基础版本完成！"),t("br"),s._v("\n有不懂的同学欢迎留言讨论。")]),s._v(" "),t("h2",{attrs:{id:"同步问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步问题"}},[s._v("#")]),s._v(" 同步问题")]),s._v(" "),t("p",[s._v("上面的代码实在是太过于基础了，有很多的不足之处。比如，在ES6的promise中，除了使用异步的方式调用resolve和reject，还支持同步的方式。")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") ")]),s._v("{\n  resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(")=>")]),s._v("{\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(value)\n},(error)=>{\n\t\n})\n")])])]),t("p",[s._v("以上代码会立即打印出1，promise在实例化时立即执行resolve，触发对应的回调函数。但如果是我们模拟的myPromise呢？")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("new MyPromise(function(resolve, reject) {\n  resolve(1)\n}).then((value)=>{\n  console.log(value)\n},(error)=>{\n\t\n})\n")])])]),t("p",[s._v("以上代码会报错： "),t("code",[s._v("TypeError: this.onFulfilled is not a function")]),t("br"),s._v("\n应该很容易理解，我们在触发resolve时，then方法还没有执行，也就是"),t("code",[s._v("this.onFulfilled")]),s._v(" 和"),t("code",[s._v("this.onRejected")]),s._v(" 还没有被赋值。此时执行resolve，调用 "),t("code",[s._v("this.onFulfilled")]),s._v(" ，当然会报错啦。")]),s._v(" "),t("p",[s._v("知道了问题，解决方案就简单了。只需要让then先执行，resolve或者reject后执行就可以了。我们可以利用时间循环机制，在resolve里加上setTimeout，让它在下一轮循环的时候才调用。")]),s._v(" "),t("p",[s._v("代码如下：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("MyPromsie")]),s._v(" ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(fn) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resolve = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") =>")]),s._v(" {\n        \t"),t("span",{staticClass:"hljs-comment"},[s._v("//加上setTimeout，下轮循环的时候才调用onFulfilled")]),s._v("\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = value\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n\n        }\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" reject = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("error")]),s._v(") =>")]),s._v(" {\n        \t"),t("span",{staticClass:"hljs-comment"},[s._v("//加上setTimeout，下轮循环的时候才调用onRejected")]),s._v("\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = error\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n        }\n\n        fn(resolve, reject)\n    }\n    then(onFulfilled, onRejected) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = onFulfilled;\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = onRejected\n    }\n}\n\n")])])]),t("p",[s._v("测试一下")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" MyPromsie("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n    resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n    reject("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n},(err)=>{\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(err)\n})\n")])])]),t("p",[s._v("以上代码会立即执行打印1，2。 这样我们就解决promise实例对象里同步调用resolve和reject的情况了。")]),s._v(" "),t("h2",{attrs:{id:"三种状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三种状态"}},[s._v("#")]),s._v(" 三种状态")]),s._v(" "),t("p",[s._v("上面的测试代码中，我们同时触发了resolve和reject，then中的两个回调函数都被调用了，同时打印出了1，2."),t("br"),s._v("\n熟悉promise的同学都知道，Promise对象有以下两个特点。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("\n（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n")])])]),t("p",[s._v("上面的话应该不难理解，下面我们来改造我们的代码，给promise添加三个状态，并满足以下需求：")]),s._v(" "),t("ol",[t("li",[s._v("只有异步操作的结果才能改变状态")]),s._v(" "),t("li",[s._v("状态只能从pending变为fulfilled和从pending变为rejected")]),s._v(" "),t("li",[s._v("一旦状态改变了，就不会再变了。再操作状态，也会立即得到这个结果")])]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("MyPromsie")]),s._v(" ")]),s._v("{\n\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(fn) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n        "),t("span",{staticClass:"hljs-comment"},[s._v("//初始状态pending")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v("\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resolve = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") =>")]),s._v(" {\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n            \t"),t("span",{staticClass:"hljs-comment"},[s._v("//只有状态是pending时才进行操作，改变为fulfilled状态")]),s._v("\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'fulfilled'")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = value\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n                }\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n\n        }\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" reject = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("error")]),s._v(") =>")]),s._v(" {\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n            \t"),t("span",{staticClass:"hljs-comment"},[s._v("//只有状态是pending时才进行操作，改变为rejected状态")]),s._v("\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'rejected'")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = error\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n                }\n\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n        }\n\n        fn(resolve, reject)\n    }\n\n    then(onFulfilled, onRejected) {\n    \t"),t("span",{staticClass:"hljs-comment"},[s._v("//只有状态是pending时才进行操作，才给回调函数赋值")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = onFulfilled;\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = onRejected\n        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'fulfilled'")]),s._v(") {\n        \t"),t("span",{staticClass:"hljs-comment"},[s._v("//如果状态已经变成fulfilled了，立即返回结果onFulfilled的执行结果")]),s._v("\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n        \t"),t("span",{staticClass:"hljs-comment"},[s._v("//如果状态已经变成rejected了，立即返回结果onRejected的执行结果")]),s._v("\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n        }\n    }\n}\n")])])]),t("p",[s._v("测试一下：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" MyPromsie("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n        resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n    }, "),t("span",{staticClass:"hljs-number"},[s._v("2000")]),s._v(")\n    reject("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n}, (err) => {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(err)\n})\n")])])]),t("p",[s._v("以上代码会立即打印2，两秒之后不会打印1.测试通过。这样我们就实现了给promise添加三种状态并让他们满足特定的需求。")]),s._v(" "),t("h2",{attrs:{id:"链式调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[s._v("#")]),s._v(" 链式调用")]),s._v(" "),t("p",[s._v("promise的诞生是为了解决回调地狱，可以说链式调用是它最强大的地方。想实现链式调用，我们可以参考jquery的实现，在方法的最后返回this。在现在的模拟实现版本中，回调函数的引用是onFullfilled和onRejected，每次调用then方法时会对onFullFilled和onRejected重新赋值，无法存储链式中所有的then中的回调函数。为了方便存储，支持链式调用，我们需要把onFullfilled和onRejected变成数组的形式。"),t("br"),s._v("\n下面看代码:")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("MyPromsie")]),s._v(" ")]),s._v("{\n\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("constructor")]),s._v("(fn) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = "),t("span",{staticClass:"hljs-string"},[s._v("''")]),s._v(";\n        "),t("span",{staticClass:"hljs-comment"},[s._v("//使用数组存储所有的回调函数，方便链式调用")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled = []\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected = []\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v("\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" resolve = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("value")]),s._v(") =>")]),s._v(" {\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'fulfilled'")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = value\n                    "),t("span",{staticClass:"hljs-comment"},[s._v("//循环调用所有的onFullfilled回调函数")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled.forEach("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("callback")]),s._v(")=>")]),s._v("{\n                        callback("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n                    })\n                }\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n        }\n\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" reject = "),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("error")]),s._v(") =>")]),s._v(" {\n            setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" {\n                "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status = "),t("span",{staticClass:"hljs-string"},[s._v("'rejected'")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error = error\n                    "),t("span",{staticClass:"hljs-comment"},[s._v("//循环调用所有的onRejected回调函数")]),s._v("\n                    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected.forEach("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("callback")]),s._v(")=>")]),s._v("{\n                        callback("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n                    })\n                }\n            }, "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(")\n        }\n\n        fn(resolve, reject)\n    }\n\n    then(onFulfilled, onRejected) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'pending'")]),s._v(") {\n        \t"),t("span",{staticClass:"hljs-comment"},[s._v("//then方法存储所有的回调函数")]),s._v("\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onFulfilled.push(onFulfilled);\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".onRejected.push(onRejected);\n        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".status === "),t("span",{staticClass:"hljs-string"},[s._v("'fulfilled'")]),s._v(") {\n            onFulfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n        } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n            onRejected("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".error)\n        }\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(";\n    }\n}\n")])])]),t("p",[s._v("测试一下")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" MyPromsie("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(")=>")]),s._v("{\n    setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v("=>")]),s._v("{\n        "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n        resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n    },"),t("span",{staticClass:"hljs-number"},[s._v("2000")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(")=>")]),s._v("{\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(")=>")]),s._v("{\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n})\n")])])]),t("p",[s._v("上面的代码回在两秒后打印3个1。这样我们就有了链式调用的一个基本雏形。之所以说是雏形，是因为这种写法有两大致命的问题。还是用上面最新的版本，我们来看一个栗子:")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" MyPromsie("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n    resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n        resolve("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(")\n    })\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n})\n")])])]),t("p",[s._v("根据我们对promise的使用印象，上面的栗子应该会打印出1和2。但是使用我们的模拟版本运行之后，打印出的是两个1。仔细分析我们不难找出问题所在：在模拟实现的代码中，每次调用then之后返回的都是this，也就是同一个promise对象，我们记为promiseA。在promiseA变为resolve状态时，它会循环调用onFullfilled中的回调函数，循环中传入的参数是this.value，所以不管链式调用多少次, this.value永远都是promiseA的value。")]),s._v(" "),t("p",[s._v("上面是我们的链式调用的第一个问题，第二个问题就是串行异步的问题。链式调用时，得等到前一个then中的回调函数执行完毕之后才会执行下一个回调函数，即使是异步的。  \n为了解决上面的问题，我们一步一步来改进我们的代码。")]),t("p"),t("p",[s._v("首先在then中，为了记录回调函数中的promise的resolve值，我们不能再返回this。但是为了达到链式调用的目的，我们必须返回一个promise对象，所以现在的then方法变成了这样")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("\tthen(onFulfilled, onRejected) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(")=>")]),s._v("{\n        \t\n      })\n   }\n")])])]),t("p",[s._v("还是上面那个栗子，")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" MyPromsie("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n    resolve("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(")\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(") =>")]),s._v(" {\n        resolve("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(")\n    })\n}).then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(") =>")]),s._v(" {\n    "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(res)\n})\n")])])]),t("p",[s._v("我们对照分析一下。假设栗子最开始创建的一个myPromise对象是promiseA，promiseA调用第一个then方法，then方法中回返回一个新的promise对象，我们称之为promiseB。那么很明显，第二个then方法对应的promise对象是promiseB，它的回调函数中的参数res是promiseB的value。")]),s._v(" "),t("p",[s._v("在第一个then方法中，有一个回调函数需要执行")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("\t（res）=>{\n    \tconsole.log(res)\n        return new Promise((resolve, reject) => {\n            resolve(2)\n        })\t\n    }\n\t\n")])])]),t("p",[s._v("这个回调函数对应的是then方法中的onFullfilled，这个回调函数需要执行，所以我们的then方法里面需要加上执行的代码")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("\tthen(onFulfilled, onRejected) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(")=>")]),s._v("{\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" x = onFullfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n      })\n   }\n")])])]),t("p",[s._v("这样回调函数就执行了，上面的回调执行之后，会返回一个新的promise，")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v("\t\treturn new Promise((resolve, reject) => {\n            resolve(2)\n        })\t\n")])])]),t("p",[s._v("我们称之为promiseC，很明显，这里的x就是promiseC的引用。第二个then执行时，我们希望打印出的结果是2，那么问题来了，在promiseC中，resolve(2)执行后，promiseC的value变成了2。但是第二个then执行时，回调函数的参数是promiseB的value。所以我们得想办法把promiseC的value给到promiseB的value。promiseC的value获取方式很简单，在promiseC的then方法中，我们可以通过回调函数的参数获取value，将它赋值给promiseB的resolve。这时的then方法变成了这样")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("\tthen(onFulfilled, onRejected) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("resolve, reject")]),s._v(")=>")]),s._v("{\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" x = onFullfilled("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value)\n        x.then("),t("span",{staticClass:"hljs-function"},[s._v("("),t("span",{staticClass:"hljs-params"},[s._v("res")]),s._v(")=>")]),s._v("{\n        \tresolve(res)\n        })\n      })\n   }\n")])])]),t("p",[s._v("此时我们就很巧妙的把promiseC的value传递给了promiseB。上面的过程有点难懂，大家可以多看几遍，还有不懂的欢迎留言讨论。"),t("br"),s._v("\nthen方法中还有返回非promise对象的情况，所以我们得做一些兼容处理，再加上一些优化的代码，最终我们的then方法变成了这样。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[s._v('then(onFulfilled, onRejected) {\n\tonFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value\n    onRejected = typeof onRejected === "function" ? onRejected : error => error\n    \n    if (self.status === FULFILLED) {\n        return new MyPromise((resolve, reject) => {\n             try {\n                let x = onFulfilled(self.value);\n                resolvePromise(x, resolve, reject);\n             } catch (e) {\n                reject(e);\n             }\n        })\n    }\n    \n    if (self.status === REJECTED) {\n        return new MyPromise((resolve, reject) => {\n            try {\n                  let x = onRejected(self.error);\n                  resolvePromise(x, resolve, reject);\n            } catch (e) {\n                  reject(e);\n            }\n        })\n    }\n    \n    if (self.status === PENDING) {\n        return new MyPromise((resolve, reject) => {\n            self.onFulfilledCallbacks.push((value) => {\n                try {\n                    let x = onFulfilled(value);\n                    resolvePromise(bridgePromise, x, resolve, reject);\n                } catch (e) {\n                    reject(e);\n                }\n            });\n            self.onRejectedCallbacks.push((error) => {\n                try {\n                    let x = onRejected(error);\n                    resolvePromise(bridgePromise, x, resolve, reject);\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    \n}\n    \n}\n\n//用来解析回调函数的返回值x，x可能是普通值也可能是个promise对象\nfunction resolvePromise(x, resolve, reject) {\n   //如果x是一个promise\n    if (x instanceof MyPromise) {\n        //如果这个promise是pending状态，就在它的then方法里继续执行resolvePromise解析它的结果，直到返回值不是一个pending状态的promise为止\n        if (x.status === PENDING) {\n            x.then(y => {\n                resolvePromise(y, resolve, reject);\n            }, error => {\n                reject(error);\n            });\n        } else {\n            x.then(resolve, reject);\n        }\n    } else {\n        resolve(x);\n    }\n}\n')])])])])}),[],!1,null,null,null);a.default=e.exports}}]);