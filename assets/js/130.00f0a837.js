(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{348:function(a,s,t){"use strict";t.r(s);var v=t(16),n=Object(v.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("title: javaScript再出发：内存空间\nauthor: jsliushen\ntags:")]),a._v(" "),t("ul",[t("li",[a._v("javascript\ncategories:")]),a._v(" "),t("li",[a._v("technology\ndate: 2017-10-02 21:57:00")])]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("作为一门高级语言，JS并不像C/C++那样拥有对内存的完全掌控。JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。正因如此，许多人认为JS不用太关心内存管理的问题，但如果不了解JS的内存管理机制，我们会非常容易造成内存泄漏（内存无法被回收）的问题。")]),a._v(" "),t("h3",{attrs:{id:"内存的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存的生命周期"}},[a._v("#")]),a._v(" 内存的生命周期")]),a._v(" "),t("p",[a._v("JS环境中分配的内存一般有如下生命周期：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存")])]),a._v(" "),t("li",[t("p",[a._v("内存使用：即读写内存，也就是使用变量、函数等")])]),a._v(" "),t("li",[t("p",[a._v("内存回收：使用完毕，由垃圾回收自动回收不再使用的内存")])])]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a = "),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n")])])]),t("p",[a._v("这句简单的代码其实已经包含了内存分配和内存使用两步，首先在内存中为变量a分配一个空间，然后在这个空间里存入一个数字1。至于内存回收，我们后面再做介绍。")]),a._v(" "),t("h3",{attrs:{id:"堆内存和栈内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆内存和栈内存"}},[a._v("#")]),a._v(" 堆内存和栈内存")]),a._v(" "),t("p",[a._v("我们来看一道很常见的面试题")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a="),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" b=a;\nb="),t("span",{staticClass:"hljs-number"},[a._v("2")]),a._v(";\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a)；   "),t("span",{staticClass:"hljs-comment"},[a._v("//1")]),a._v("\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(b);    "),t("span",{staticClass:"hljs-comment"},[a._v("//2")]),a._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj1={"),t("span",{staticClass:"hljs-attr"},[a._v("a")]),a._v(":"),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v("};\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj2=obj1;\nobj2.a="),t("span",{staticClass:"hljs-number"},[a._v("2")]),a._v(";\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a);     "),t("span",{staticClass:"hljs-comment"},[a._v("//{a:2}")]),a._v("\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(b);     "),t("span",{staticClass:"hljs-comment"},[a._v("//{a:2}")]),a._v("\n")])])]),t("p",[a._v("代码的第一部分，b的值改变时，a的值不受影响。第二部分，obj2.a改变时，obj1受到影响，一起改变。这里的a，b和obj1，obj2有什么区别，为什么会有不同的效果。下面先介绍一下内存空间的分类：一种叫做栈（stack），另一种叫做堆（heap）；")]),a._v(" "),t("p",[a._v("栈中的数据块按照一定次序存放（后进先出），栈结构和羽毛球筒存取羽毛球很相似，大家可以脑补一下。假设羽毛球筒中按循序存放了1，2，3，4，5个球，最底下是1号球，最上面是5好球，很明显1号是最先放入筒中的。现在我想使用羽毛球，最先使用的就应该是5号球，这就是所谓的后进先出。同样，如果我想使用4号球，就必须先取出5号球，然后才能取出4号球。")]),a._v(" "),t("p",[a._v("堆数据结构存取数据的方式，则与书架与书非常相似。\n书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从羽毛球筒里取羽毛球一样，非得将上面的羽毛球拿出来才能取到中间的某一个羽毛球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。")]),a._v(" "),t("p",[a._v("下面用几句代码和一张图来帮助大家理解内存空间")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v('var a=1;\nvar b=false;\nvar c={name:"zhangSan",age:20}\nvar d=[1,2,3,4]\n')])])]),t("p",[t("img",{attrs:{src:"/images/stackandheap.jpg",alt:""}})]),a._v(" "),t("p",[a._v("我们可以看到，变量a，b和变量c，d在内存空间中的存储方式不一样，这种不同的存储方式就造成了他们在进行赋值等操作的时候会有不同的行为，而这和他们的数据类型有关。在javaScript中，数据类型可以分为两种：")]),a._v(" "),t("p",[a._v("值类型：数值、布尔值、null、undefined。")]),a._v(" "),t("p",[a._v("引用类型：对象、数组、函数")]),a._v(" "),t("p",[a._v("对于值类型的变量，数据存储在栈内存中。对于引用类型的变量，数据分两部分存储，一部分是对象的内存地址（指针），存储在栈内存中，一部分是对象真实的数据，存储在堆内存中。")]),a._v(" "),t("p",[a._v("理解这个之后，我们再来分析一下前面提到的面试题。")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a="),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" b=a;\nb="),t("span",{staticClass:"hljs-number"},[a._v("2")]),a._v(";\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a)；   "),t("span",{staticClass:"hljs-comment"},[a._v("//1")]),a._v("\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(b);    "),t("span",{staticClass:"hljs-comment"},[a._v("//2")]),a._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj1={"),t("span",{staticClass:"hljs-attr"},[a._v("a")]),a._v(":"),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v("};\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj2=obj1;\nobj2.a="),t("span",{staticClass:"hljs-number"},[a._v("2")]),a._v(";\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(obj1);     "),t("span",{staticClass:"hljs-comment"},[a._v("//{a:2}")]),a._v("\n"),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(obj2);     "),t("span",{staticClass:"hljs-comment"},[a._v("//{a:2}")]),a._v("\n")])])]),t("p",[a._v("第一部分，第一句代码，声明一个变量a，然后赋值为1，这一部分相当于在内存中开辟了一个新的空间，取名叫a，然后在这个空间里存储了一个值1。\n第二句代码，声明一个变量b，然后将a赋值给它。这一部分相当于在内存中新开辟了一个空间，取名叫b，然后在这个空间里放上a的值（把a的值复制一份给b），也就是1。\n这两句代码完成后，栈内存中多了两个空间，a和b，都存储着1。然后第三句代码把b重新赋值为2，相当于把空间b里的值换了一个，这个时候和a没有关系，a中的值不受影响。")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/stackandheap2.png",alt:""}})]),a._v(" "),t("p",[a._v("第二部分，第一句代码，声明一个变量obj1，赋值为一个对象{a:1}。这个时候在内存中开辟了一个新的空间叫做obj1，里面存储着{a:1}在堆内存中的地址，假设是0x234hda。\n第二句代码，声明一个变量obj2，然后将obj1的值赋给他。这个时候在内存中开辟了一个新的存储空间，取名叫obj2，然后在这个空间里放上obj1的值（把这个地址复制一份给obj2），也就是0x234hda。\n这两句代码完成之后，obj1和obj2的栈内存中都存储的是0x234hda。然后执行第三句代码obj2.a=2,这时候发生的事情如下：根据obj2的值0x234hda找到堆内存中存储着的{a:1},然后找到属性a，把它修改为2。这个时候obj1和obj2的栈内存中存储的依然是0x234hda，但是这个地址所对应的对象{a:1}已经变成了{a:2}。")]),a._v(" "),t("p",[a._v("继续执行代码，打印obj1,这个时候根据obj1中存储的0x234hda地址找到那个对象{a:2},打印出来，于是我们就看到了{a:2}。打印obj2,这个时候根据obj2中存储的0x234hda地址找到那个对象{a:2},打印出来，于是我们就看到了{a:2}。")]),a._v(" "),t("p",[a._v("这就是为什么我们修改了obj1之后，obj2也会受到影响。\n"),t("img",{attrs:{src:"/images/stackandheap3.png",alt:""}})]),a._v(" "),t("p",[a._v("为了帮助大家理解，我再举一个生活化的例子。小明和小华住在一个寝室，有一天小明买了一袋洗衣粉，放在了寝室的东南角。第二天小华想找小明借洗衣粉，小明说洗衣粉在“寝室东南角”，小华根据这个地址找到了洗衣粉，用了一半。第三天，小明去用洗衣粉，根据“寝室东南角”找，这个时候他就发现洗衣粉只剩下一半了。")]),a._v(" "),t("p",[a._v("以上就是值类型，引用类型以及堆内存，栈内存的概念讲解，如果有不理解的或者有不同见解的同学，欢迎留言讨论。最后我们再说明一下，当内存中的数据使用完毕时，javaScript是如何对他们进行回收的。")]),a._v(" "),t("h3",{attrs:{id:"垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[a._v("#")]),a._v(" 垃圾回收算法")]),a._v(" "),t("p",[a._v("对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用了。下面介绍两种常见浏览器的垃圾回收算法。")]),a._v(" "),t("h4",{attrs:{id:"引用计数算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),t("p",[a._v("引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。")]),a._v(" "),t("p",[a._v("下面来看个例子：")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[t("span",{staticClass:"hljs-comment"},[a._v("// 创建一个对象person，他有两个指向属性age和name的引用")]),a._v("\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" person = {\n    "),t("span",{staticClass:"hljs-attr"},[a._v("age")]),a._v(": "),t("span",{staticClass:"hljs-number"},[a._v("18")]),a._v(",\n    "),t("span",{staticClass:"hljs-attr"},[a._v("name")]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v("'zhangSan'")]),a._v("\n};\n\nperson.name = "),t("span",{staticClass:"hljs-literal"},[a._v("null")]),a._v("; "),t("span",{staticClass:"hljs-comment"},[a._v("// 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收")]),a._v("\n\n"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" p = person; \nperson = "),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";         "),t("span",{staticClass:"hljs-comment"},[a._v("//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收")]),a._v("\n\np = "),t("span",{staticClass:"hljs-literal"},[a._v("null")]),a._v(";           "),t("span",{staticClass:"hljs-comment"},[a._v("//原person对象已经没有引用，很快会被回收")]),a._v("\n")])])]),t("p",[a._v("由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[a._v("function")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("cycle")]),a._v("("),t("span",{staticClass:"hljs-params"}),a._v(") ")]),a._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj1 = {};\n    "),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" obj2 = {};\n    obj1.a = obj2;\n    obj2.a = obj1; \n}\n\ncycle();\n")])])]),t("p",[a._v("上面我们申明了一个cycle函数，其中包含两个相互引用的对象。在调用函数结束后，对象o1和o2实际上已离开函数范围，因此不再需要了。但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收，内存泄露不可避免了。")]),a._v(" "),t("p",[a._v("正是因为有这个严重的缺点，这个算法在现代浏览器中已经被下面要介绍的标记清除算法所取代了。但绝不可认为该问题已经不再存在了，因为还占有大量市场的IE6、IE7使用的正是这一算法。")]),a._v(" "),t("h4",{attrs:{id:"标记清除算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[a._v("#")]),a._v(" 标记清除算法")]),a._v(" "),t("p",[a._v("上面说过，现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。")]),a._v(" "),t("p",[a._v("标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。")]),a._v(" "),t("p",[a._v("从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。")])])}),[],!1,null,null,null);s.default=n.exports}}]);