(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{331:function(s,a,t){"use strict";t.r(a);var n=t(16),l=Object(n.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("几乎所有编程语言最基本的功能之一，就是能够存储变量当中的值，并且能在之后对这个值进行访问或修改。随着变量的引入，就有几个问题需要我们思考：这些变量住在哪里？换句话说，它们存储在哪里？最重要的是，程序需要时如何找到他们？\n这些问题都表明，编程语言需要有一套良好的规则来存储变量，并且之后可以方便地找到这些变量，这套规则就被成为作用域。"),t("br")]),s._v(" "),t("h2",{attrs:{id:"全局作用域和函数作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域和函数作用域"}},[s._v("#")]),s._v(" 全局作用域和函数作用域")]),s._v(" "),t("p",[s._v("在javascript中，作用域有三种：全局作用域，函数作用域和块级作用域。其中块级作用域是在es6推出let关键字之后才被广泛使用，我们这里不做讨论。\n先来说说全局作用，我们在写代码时，script标签中最外层的作用域就是全局作用域。需要说明一点，所有声明在全局作用域中的变量都是window对象的属性。")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("    <script>\n\t  var a=1;\n    <\/script>\n    //上面的代码等价于\n    <script>\n\t  window.a=1;\n    <\/script>\n")])])]),t("p",[s._v("函数作用域也就是函数花括号内部包含的范围")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("\t  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n      "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("func")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b="),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n      }\n      \n")])])]),t("p",[s._v("以上代码中，变量a处在全局作用域，变量b处在func的函数作用域。"),t("br")]),s._v(" "),t("h2",{attrs:{id:"作用域嵌套"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套"}},[s._v("#")]),s._v(" 作用域嵌套")]),s._v(" "),t("p",[s._v("在编写项目时，肯定会有很多的函数，这些函数都有自己的作用域，不可避免的就会造成作用域的嵌套，比如：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n  "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("func1")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n    func2();\n    "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("func2")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" b="),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n      func3();\n      "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("func3")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n        "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(a);   "),t("span",{staticClass:"hljs-comment"},[s._v("//2")]),s._v("\n        "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(d);   "),t("span",{staticClass:"hljs-comment"},[s._v("//ReferenceError: Can't find variable: d")]),s._v("\n      }\n    }\n  }\n  func1();\n")])])]),t("p",[s._v("以上代码在执行时，有全局作用域，有func1的函数作用域，有func2的函数作用域，还有func3的函数作用域，这些作用域层层嵌套，外层包含内层。对于这种嵌套的作用域，查找变量的规则也很简单，首先在当前作用域中查找某个变量，如果当前作用域中没有找到，就往外层作用域中寻找，直到最外层也就是全局作用域。一旦找到，就停止查找，如果到了全局作用域中还是没有找到，就说明那么变量不存在。"),t("br"),s._v("\n我们看看上面的代码，打印a的时候，首先在函数func3的函数作用域中查找a,找不到，于是去外层func2的函数作用域中查找，又找不到，再去外层func1的函数作用域中查找，这时候发现有一个变量a，于是停止查找，就取这个a的值2，打印出来。打印d时候，根据同样的规则，一直查找到全局作用域都没有找到变量d，于是报错提示，找不到变量d。"),t("br"),s._v("\n变量的查找是由内向外的，也就是说外层作用域是查找不到内层作用域中的变量的。比如说：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("   "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(a);  "),t("span",{staticClass:"hljs-comment"},[s._v("//ReferenceError: Can't find variable: a")]),s._v("\n   "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("func")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n   }\n \n")])])]),t("p",[s._v("上面代码打印a，当前全局作用域没有a，但是内层的func函数作用域中有变量a，这种情况下外层也不会往内层作用域中去查找，于是最终程序报错，找不到变量a。")]),s._v(" "),t("p",[s._v("这个很好理解，但还是要特别说明一点，像if条件语句和for循环语句这种结构中是没有自己的作用域的（除非内部使用的是let声明的变量，这个以后再说，暂不讨论）。我们来看一段代码")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[s._v("   "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n   "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("(a>"),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("){\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n   }\n   "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(a);\n")])])]),t("p",[s._v("很多同学看到这段代码时，很容易觉得if语句中的a所处的作用域是那个花括号，打印的a的时候获取不到这个内部作用域中的a，获取到的是全局作用域中的a，于是打印1。但是最终结果打印的却是2。if语句的花括号没有自己的作用域，里面的\n"),t("code",[s._v("var a=2")]),s._v("\n实际上取到的还是全局作用域中的a，把a重新赋值为2，打印的时候取到的也是全局作用域中的a，所以会打印2。")]),s._v(" "),t("h2",{attrs:{id:"词法作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[s._v("#")]),s._v(" 词法作用域")]),s._v(" "),t("p",[s._v("现阶段的编程语言作用域有两种，一种是静态作用域（也叫词法作用域），还有一种是动态作用域。他们的区别在于，静态作用域中的函数，函数的作用域在定义时就决定好了，与在哪调用无关，而动态作用域中的函数，函数的作用域需要在调用时才能确定。"),t("br"),s._v("\n举个栗子：")]),s._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(";\n"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("fun1")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n\t"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(a);\n}\n"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("fun2")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n\t"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a="),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n    fun1();\n}\nfun2();   "),t("span",{staticClass:"hljs-comment"},[s._v("//1")]),s._v("\n")])])]),t("p",[s._v("我们分析一下上面的代码，在全局作用域中有一个变量a，赋值为1。执行函数fun2,在fun2中定义了一个变量a，赋值为2，然后执行fun1，在fun1的函数体中，打印变量a。这个时候问题来了，这个变量a怎么找，整个代码中，有两个a，到底这里打印的是哪一个。"),t("br"),s._v("\n假设javascript属于动态作用域，那么a应该在fun1调用时所处的作用域中去寻找。让我们来找找看，首先在函数fun1中找变量a，这个时候找遍fun1的内部作用域都找不到我们需要的a，于是只能到外层去寻找，调用时外层是fun2，这时候发现fun2中有一个变量a，于是停止寻找，打印这个a的值，也就是2。但是实际上最终结果打印的是1，所以很明显，javascript采用的是静态作用域，函数的作用域在函数定义时就已经确定了"),t("br"),s._v("\n以上内容还是很好理解的，大家如果有无法理解或者不同的，欢迎留言讨论。")])])}),[],!1,null,null,null);a.default=l.exports}}]);