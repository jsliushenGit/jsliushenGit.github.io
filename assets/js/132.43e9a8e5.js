(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{329:function(a,s,t){"use strict";t.r(s);var n=t(16),v=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("title: javaScript再出发：执行上下文\nauthor: jsliushen\ntags:")]),a._v(" "),t("ul",[t("li",[a._v("javascript\ncategories:")]),a._v(" "),t("li",[a._v("technology\ndate: 2017-10-09 13:57:00")])]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("先来看一段代码：")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[a._v("  "),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a);   "),t("span",{staticClass:"hljs-comment"},[a._v("//undefined")]),a._v("\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a="),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n")])])]),t("p",[a._v("对javascript有所了解的同学肯定听说过声明提升这个概念，在javascript代码正式执行之前会进行一些”准备工作“，这个准备工作会将变量和函数的声明部分提前到当前作用域的顶端，也就是说上面的代码执行时实际上是这样的：")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("\t"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a;\n    "),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a);\n    a="),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n")])])]),t("p",[a._v('今天我们要讨论的就是这个"准备工作"到底是什么，为什么会发生声明提升。'),t("br")]),a._v(" "),t("h3",{attrs:{id:"执行上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[a._v("#")]),a._v(" 执行上下文")]),a._v(" "),t("p",[a._v('在javascript遇到可执行代码时，就会创建一个执行上下文，也就是上文中"准备工作"的专业说法。所谓的可执行代码，根据字面意思就是可以执行的代码，简单来说就三种：全局代码（全局环境下的代码），函数代码（函数体中的代码），eval代码（eval中的代码）。'),t("br"),a._v("\n对于执行上下文，有三个重要的属性：")]),a._v(" "),t("ul",[t("li",[a._v("变量对象")]),a._v(" "),t("li",[a._v("作用域链")]),a._v(" "),t("li",[a._v("this")])]),a._v(" "),t("p",[a._v("在执行上下文的创建阶段，会创建变量对象，建立作用域链，以及确定this的指向。这三个概念我们后续会专门写三篇文章进行分析，今天我们只讨论执行上下文的执行流程")]),a._v(" "),t("h3",{attrs:{id:"执行上下文栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文栈"}},[a._v("#")]),a._v(" 执行上下文栈")]),a._v(" "),t("p",[a._v("上看说到javascript每次遇到可执行代码都会创建一个执行上下文(Excution context stack)，那么随着函数的增多，这么多的执行上下文要怎么去管理。"),t("br"),a._v("\n浏览器中的javascript解释器是单线程的，同一时间只能做一件事，其他的事件和行为会以栈的形式进行排队，关于栈的结构，系列的"),t("a",{attrs:{href:"http://jsliushen.com/%E5%89%8D%E7%AB%AF/javaScript%E5%86%8D%E5%87%BA%E5%8F%91-%E4%B8%80-%EF%BC%9A%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/"}},[a._v("第一篇")]),a._v("已经介绍过了，不熟悉的同学可以回看复习。"),t("br"),a._v("\n当遇到可执行代码A时，当前代码的上下文ESC-A入栈，开始执行A中的代码，执行过程中遇到新的可执行代码B时，新的可执行代码的上下文ESC-B入栈，开始执行B中的代码，当B中的代码执行完毕时，ESC-B出栈，继续执行ESC-A中的代码。也就是说，永远只有栈顶的代码在执行，栈顶下面的代码处于等待状态。"),t("br"),a._v("\n我们使用数组模拟一下执行上下文栈的行为：")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("\tECStack=[];\n")])])]),t("p",[a._v("以一段代码为例，我们分析一下执行上下文栈的具体执行流程：")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("\t"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a="),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v(";\n    "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[a._v("function")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("fun1")]),a._v("("),t("span",{staticClass:"hljs-params"}),a._v(")")]),a._v("{\n    \t"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" b="),t("span",{staticClass:"hljs-number"},[a._v("2")]),a._v(";\n        "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[a._v("function")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("fun2")]),a._v("("),t("span",{staticClass:"hljs-params"}),a._v(")")]),a._v("{\n        \t"),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" c="),t("span",{staticClass:"hljs-number"},[a._v("3")]),a._v(";\n            "),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(b);\n        }\n    }\n    fun1()\n    "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[a._v("function")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("fun4")]),a._v("("),t("span",{staticClass:"hljs-params"}),a._v(")")]),a._v("{\n       "),t("span",{staticClass:"hljs-built_in"},[a._v("console")]),a._v(".log(a)\n    }\n    fun4()\n")])])]),t("p",[a._v("首先进入代码，遇到可执行代码")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("   "),t("span",{staticClass:"hljs-keyword"},[a._v("var")]),a._v(" a = "),t("span",{staticClass:"hljs-number"},[a._v("1")]),a._v("\n")])])]),t("p",[a._v(",这时所处的环境是全局上下文，全局上下文Global Context入栈：")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("\tECStack.push(globalContext)\n")])])]),t("p",[t("img",{attrs:{src:"/images/javascript-run-again3/1.png",alt:""}})]),a._v(" "),t("p",[a._v("Global Context入栈之后执行全局代码，这时遇到可执行的函数fun1，函数fun1上下文fun1 Context入栈")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("\tECStack.push(fun1Context)\n")])])]),t("p",[t("img",{attrs:{src:"/images/javascript-run-again3/2.png",alt:""}})]),a._v(" "),t("p",[a._v("fun1 Context入栈之后开始执行fun1函数体中的代码，这里有个问题，fun1中声明了一个函数fun2，但是并没有去执行fun2，所以这里并不会创建新的上下文。一直到fun1执行结束，此时fun1 Context出栈")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("  ECStack.pop(fun1Context)\n")])])]),t("p",[t("img",{attrs:{src:"/images/javascript-run-again3/1.png",alt:""}})]),a._v(" "),t("p",[a._v("fun1 Context出栈之后，此时栈顶的是Global Context，继续执行全局代码，此时遇到可执行的函数fun4，函数fun4上下文fun4 Context入栈")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("  ECStack.push(fun4Context)\n")])])]),t("p",[t("img",{attrs:{src:"/images/javascript-run-again3/3.png",alt:""}})]),a._v(" "),t("p",[a._v("fun4 Context入栈之后开始执行fun4函数体中的代码，执行完毕之后，fun4 Context出栈")]),a._v(" "),t("div",{staticClass:"language-javaScript extra-class"},[t("pre",[t("code",{staticClass:"language-javaScript"},[a._v("ECStack.pop(fun4Context)\n")])])]),t("p",[t("img",{attrs:{src:"/images/javascript-run-again3/1.png",alt:""}})]),a._v(" "),t("p",[a._v("fun4 Context出栈之后，此时栈顶的是Global Context，继续执行全局代码，直到浏览器关闭"),t("br"),a._v("\n详细解释这个过程之后，我们就可以来对执行上下文做一个总结了")]),a._v(" "),t("ul",[t("li",[a._v("遇到可执行代码时，就会创建一个可执行上下文，并将其压入可执行上下文栈")]),a._v(" "),t("li",[a._v("只有栈顶的上下文处于执行状态，其他上下文等待")]),a._v(" "),t("li",[a._v("同步执行，栈顶的上下文执行完毕之后，才执行下一个上下文")])])])}),[],!1,null,null,null);s.default=v.exports}}]);