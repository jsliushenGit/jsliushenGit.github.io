(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{448:function(s,t,a){"use strict";a.r(t);var e=a(16),v=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[s._v("#")]),s._v(" 语法")]),s._v(" "),a("p",[s._v("对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。")]),s._v(" "),a("ul",[a("li",[s._v("声明形式(对象字面量):")])]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObj = { \n  "),a("span",{staticClass:"hljs-attr"},[s._v("key")]),s._v(": value\n  "),a("span",{staticClass:"hljs-comment"},[s._v("// ... ")]),s._v("\n};\n")])])]),a("ul",[a("li",[s._v("构造形式:")])]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObj = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),a("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v("(); \nmyObj.key = value;\n")])])]),a("p",[s._v("构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。")]),s._v(" "),a("h2",{attrs:{id:"类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[s._v("#")]),s._v(" 类型")]),s._v(" "),a("p",[s._v('在JavaScript中一共有6中主要类型(术语是"语言类型")')]),s._v(" "),a("ul",[a("li",[s._v("string")]),s._v(" "),a("li",[s._v("number")]),s._v(" "),a("li",[s._v("boolean")]),s._v(" "),a("li",[s._v("null")]),s._v(" "),a("li",[s._v("undefined")]),s._v(" "),a("li",[s._v("object")])]),s._v(" "),a("p",[s._v('简单数据类型:\t\t\n其中string、boolean、number、null 和 undefined属于简单基本类型,并不属于对象.\t\nnull 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 "object"。实际上，null 本身是基本类型。\nPS: 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。')]),s._v(" "),a("p",[s._v("对象:\n对象除了我们自己手动创建的,JavaScript其实内置了很多对象,也可以说是对象的一个子类型.")]),s._v(" "),a("p",[s._v("内置对象:")]),s._v(" "),a("ul",[a("li",[s._v("String")]),s._v(" "),a("li",[s._v("Number")]),s._v(" "),a("li",[s._v("Boolean")]),s._v(" "),a("li",[s._v("Object")]),s._v(" "),a("li",[s._v("Function")]),s._v(" "),a("li",[s._v("Array")]),s._v(" "),a("li",[s._v("Date")]),s._v(" "),a("li",[s._v("RegExp")]),s._v(" "),a("li",[s._v("Error")])]),s._v(" "),a("p",[s._v("在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数(由 new 产生的函数调用——参见第 2 章)来使用.")]),s._v(" "),a("p",[s._v("几点说明:")]),s._v(" "),a("ul",[a("li",[s._v("函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。")]),s._v(" "),a("li",[s._v("通过字面量形式创建字符串,数字,布尔时,引擎会自动把字面量转换成 String 对象,Number对象,Boolean对象，所以它们是可以访对应对象内置的问属性和方法。")]),s._v(" "),a("li",[s._v("null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。")]),s._v(" "),a("li",[s._v("对于 Object、Array、Function 和 RegExp(正则表达式)来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量(这是肯定的,因为不管哪种形式一创建出来就是对象类型,不可能是其他类型,实际上是不存在字面量这一说的)。但是使用构造形式可以提供一些额外选项(内置)。")]),s._v(" "),a("li",[s._v("Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。")])]),s._v(" "),a("h2",{attrs:{id:"内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[s._v("#")]),s._v(" 内容")]),s._v(" "),a("p",[s._v("对象属性:由一些存储在特定命名位置的(任意类型的)值.\t\n属性名:存储在对象容器内部的属性的名称.属性值并不会存在对象内.而是通过属性名(就像指针,从技术角度来说就是引用)来指向这些值真正的存储位置(就像房门号一样).\n属性名的两种形式:")]),s._v(" "),a("ul",[a("li",[a("p",[s._v('使用.操作符.也是我们最常用的形式.它通常被称为"属性访问". . 操作符会要求属性名满足标识符的命名规范.')])]),s._v(" "),a("li",[a("p",[s._v('使用[".."]语法进行访问.这个通常被称为"键访问".[".."]语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且[".."]语法使用字符串来访问属性,如果你的属性名是一个变量,则可以使用书中的例子myObject[idx]形式进行访问.这也是最常使用"键访问"的情况.但如果idx是属性名则还是需写成myObject["idx"]字符串形式.')])])]),s._v(" "),a("p",[s._v("注意: 书中说在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的确是数字，但是在对象属性名中数字会被转换成字符串 . 在ES6之前这段话是正确的,但是现在有了symbol. symbol也可以作为对象属性名使用,并且symbol是不可以转化为字符串形式的!")]),s._v(" "),a("h3",{attrs:{id:"可计算属性名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可计算属性名"}},[s._v("#")]),s._v(" 可计算属性名")]),s._v(" "),a("p",[s._v("ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:")]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" prefix = "),a("span",{staticClass:"hljs-string"},[s._v('"foo"')]),s._v(";\n\n"),a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObject = {\n   [prefix + "),a("span",{staticClass:"hljs-string"},[s._v('"bar"')]),s._v("]:"),a("span",{staticClass:"hljs-string"},[s._v('"hello"')]),s._v(", \n   [prefix + "),a("span",{staticClass:"hljs-string"},[s._v('"baz"')]),s._v("]: "),a("span",{staticClass:"hljs-string"},[s._v('"world"')]),s._v("\n};\nmyObject["),a("span",{staticClass:"hljs-string"},[s._v('"foobar"')]),s._v("]; "),a("span",{staticClass:"hljs-comment"},[s._v("// hello")]),s._v("\nmyObject["),a("span",{staticClass:"hljs-string"},[s._v('"foobaz"')]),s._v("]; "),a("span",{staticClass:"hljs-comment"},[s._v("// world")]),s._v("\n")])])]),a("h3",{attrs:{id:"属性与方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性与方法"}},[s._v("#")]),s._v(" 属性与方法")]),s._v(" "),a("p",[s._v("我们经常把对象内部引用的函数称为“方法”(的确如此).\n实际上函数并不属于该对象,它不过是对函数的引用罢了.对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。\n即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。")]),s._v(" "),a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[s._v("#")]),s._v(" 数组")]),s._v(" "),a("p",[s._v('数组支持 [] 形式访问储存的值,其中 [] 内的值默认形式为数值下标(为从0开始的整数,也就是常说的索引).例如myArray[0]\n数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性.例如myArray.baz = "baz".注意:添加新属性后,虽然可以访问,但数组的 length 值不会改变.\n数组可以通过myArray[1]=11;myArray["2"]=22;这种形式对数组内容进行修改,添加.\n虽然数组也可以和对象一样通过键/值 对 形式来使用.但JS已经对数组的行为和用途进行了优化.所以还是建议使用默认的下标/值 对 形式来使用.')]),s._v(" "),a("h3",{attrs:{id:"复制对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制对象"}},[s._v("#")]),s._v(" 复制对象")]),s._v(" "),a("p",[s._v('复制分为浅拷贝和深拷贝.浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域),对于对象则是继续引用.而不是重新创建一个"一样的"对象.深拷贝则是对其中的所有内(容包括对象)进行深层次的复制.\n一般情况下我们可以通过JSON来复制对象.var newObj = JSON.parse( JSON.stringify( someObj ) );.但需要指出的是这种方法对于包含function函数或者Date类型的对象则不管用!\nES6 定义了 Object.assign(..) 方法来实现浅复制。具体用法在这就不赘述了.')]),s._v(" "),a("h3",{attrs:{id:"属性描述符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性描述符"}},[s._v("#")]),s._v(" 属性描述符")]),s._v(" "),a("p",[s._v("从 ES5 开始，所有的属性都具备了属性描述符。")]),s._v(" "),a("ul",[a("li",[s._v('查看属性描述符: 可以使用Object.getOwnPropertyDescriptor( myObject, "a" );方法查看myObject对象里属性a的属性描述符.')]),s._v(" "),a("li",[s._v("配置属性描述符: 可以使用Object.defineProperty(..)方法对属性的属性描述符就像配置.举个例子:")])]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObject = {};\n"),a("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".defineProperty( myObject, "),a("span",{staticClass:"hljs-string"},[s._v('"a"')]),s._v(", {\n  "),a("span",{staticClass:"hljs-attr"},[s._v("value")]),s._v(": "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(",\n  "),a("span",{staticClass:"hljs-attr"},[s._v("writable")]),s._v(": "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", \n  "),a("span",{staticClass:"hljs-attr"},[s._v("configurable")]),s._v(": "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(", \n  "),a("span",{staticClass:"hljs-attr"},[s._v("enumerable")]),s._v(": "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v("\n} );\nmyObject.a; "),a("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n"),a("span",{staticClass:"hljs-comment"},[s._v("//该方法可以配置四个属性描述符")]),s._v("\n")])])]),a("p",[s._v("下面分别介绍剩下的三个属性描述符键值:")]),s._v(" "),a("ol",[a("li",[s._v("Writable   决定是否可以修改属性的值。当被设置为false后,再对属性值进行修改,则会静默失败(silently failed,修改不成功,也不报错)了。如果在严格模式下，则会报出TypeError错误.")]),s._v(" "),a("li",[s._v("Configurable 决定属性描述符是否可配置.如果为true,就可以使用 defineProperty(..) 方法来修改属性描述符.注意:不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且把 configurable 修改成 false 是单向操作，无法撤销! 但是有个例外即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性.")]),s._v(" "),a("li",[s._v("Enumerable  决定该属性是否会出现在对象的属性枚举中.比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。")])]),s._v(" "),a("h3",{attrs:{id:"不变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不变性"}},[s._v("#")]),s._v(" 不变性")]),s._v(" "),a("p",[s._v("除了上面提到的Object.defineProperty(..),ES5还可以通过很多种方法来实现属性或者对象的不可变.")]),s._v(" "),a("p",[s._v("注意: 这些所有方法都是只能浅不变,如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的.类似于浅拷贝.")]),s._v(" "),a("p",[s._v("说明:  在 JavaScript 程序中很少需要深不可变性。 有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。")]),s._v(" "),a("p",[s._v("方法:")]),s._v(" "),a("ol",[a("li",[s._v("对象常量(不可改) 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除)")]),s._v(" "),a("li",[s._v("禁止扩展(不可增) 使用 Object.prevent Extensions(myObject),可以禁止一个对象添加新属性并且保留已有属性.在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。")]),s._v(" "),a("li",[s._v("密封(不可配置,但可修改) 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。")]),s._v(" "),a("li",[s._v("冻结(不可配置,也不可修改) Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。")])]),s._v(" "),a("p",[s._v("注意: 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎!因为你引用的对象可能会在其他地发也被引用.")]),s._v(" "),a("p",[s._v("说明: 在 JavaScript 程序中很少需要深不可变性。有些特殊情况可能需要这样做， 但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。")]),s._v(" "),a("h3",{attrs:{id:"get"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[s._v("#")]),s._v(" [[Get]]")]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObject = { \n   "),a("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("\n};\nmyObject.a; "),a("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n")])])]),a("p",[s._v("myObject.a是怎么取到值2的?")]),s._v(" "),a("p",[s._v("myObject.a 通过对象默认内置的[[Get]] 操作(有点像函数调用:[Get]).首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined.")]),s._v(" "),a("p",[s._v("注意: 如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常.")]),s._v(" "),a("h3",{attrs:{id:"put"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[s._v("#")]),s._v(" [[Put]]")]),s._v(" "),a("p",[s._v("既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性.\n[[Put]] 被触发时的操作分为两个情况:1. 对象中已经存在这个属性 2. 对象中不存在这个属性.\n如果对象中已经存在这个属性,[[Put]] 算法大致会检查下面这些内容:")]),s._v(" "),a("ul",[a("li",[s._v("属性是否是访问描述符(参见下一节)?如果是并且存在setter就调用setter。")]),s._v(" "),a("li",[s._v("属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。")]),s._v(" "),a("li",[s._v("如果都不是，将该值设置为属性的值。")])]),s._v(" "),a("p",[s._v("如果对象中不存在这个属性，[[Put]] 操作会更加复杂。会在第 5 章讨论 [[Prototype]] 时详细进行介绍。")]),s._v(" "),a("h3",{attrs:{id:"getter和setter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter和setter"}},[s._v("#")]),s._v(" Getter和Setter")]),s._v(" "),a("p",[s._v("对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。\t\n目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ,但是在ES5中可以使用 getter 和 setter 改写部分默认操作,只能应用在单个属性上，无法应用在整个对象上。")]),s._v(" "),a("p",[s._v("getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作.当你设置getter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性.")]),s._v(" "),a("p",[s._v("语法: {get prop() { ... } }或{get "),a("a",{attrs:{href:""}},[s._v("expression")]),s._v(" { ... } }.其中prop:要设置的属性名. expression:从 ECMAScript 2015 开始可以使用计算属性名.")]),s._v(" "),a("p",[s._v("使用方式:")]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObject = {\n  "),a("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),a("span",{staticClass:"hljs-number"},[s._v("1111")]),s._v(", "),a("span",{staticClass:"hljs-comment"},[s._v("//在后面会发现myObject.a为2,这是因为设置了getter所以忽略了value特性.")]),s._v("\n  "),a("span",{staticClass:"hljs-comment"},[s._v("//方式一:在新对象初始化时定义一个getter")]),s._v("\n  "),a("span",{staticClass:"hljs-keyword"},[s._v("get")]),s._v(" a() {\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("\n  }\n};\n\n"),a("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".defineProperty( \n  myObject, "),a("span",{staticClass:"hljs-comment"},[s._v("// 目标对象 ")]),s._v("\n  "),a("span",{staticClass:"hljs-string"},[s._v('"b"')]),s._v(", "),a("span",{staticClass:"hljs-comment"},[s._v("// 属性名")]),s._v("\n  {\n    "),a("span",{staticClass:"hljs-comment"},[s._v("// 方式二:使用defineProperty在现有对象上定义 getter")]),s._v("\n    "),a("span",{staticClass:"hljs-attr"},[s._v("get")]),s._v(": "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{ "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".a * "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(" },\n    "),a("span",{staticClass:"hljs-comment"},[s._v("// 确保 b 会出现在对象的属性列表中")]),s._v("\n    "),a("span",{staticClass:"hljs-attr"},[s._v("enumerable")]),s._v(": "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v("\n   }\n);\n\nmyObject.a = "),a("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(";  "),a("span",{staticClass:"hljs-comment"},[s._v("//因为设置了getter所以忽略了writable特性.所以这里赋值没成功")]),s._v("\nmyObject.a; "),a("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\nmyObject.b; "),a("span",{staticClass:"hljs-comment"},[s._v("// 4")]),s._v("\n\n"),a("span",{staticClass:"hljs-keyword"},[s._v("delete")]),s._v(" myObject.a;"),a("span",{staticClass:"hljs-comment"},[s._v("//可以使用delete操作符删除")]),s._v("\n")])])]),a("p",[s._v("setter:\t\nsetter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).当你设置setter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性.\n语法: {set prop(val) { . . . }}或{set "),a("a",{attrs:{href:"val"}},[s._v("expression")]),s._v(" { . . . }}.其中prop:要设置的属性名. val:用于保存尝试分配给prop的值的变量的一个别名。expression:从 ECMAScript 2015 开始可以使用计算属性名.")]),s._v(" "),a("p",[s._v("使用方式:")]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" myObject = {\n  "),a("span",{staticClass:"hljs-comment"},[s._v("//注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):")]),s._v("\n  "),a("span",{staticClass:"hljs-comment"},[s._v("//方式一:在新对象初始化时定义一个setter")]),s._v("\n  "),a("span",{staticClass:"hljs-keyword"},[s._v("set")]),s._v(" a(val) {\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("._a_ = val * "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("\n  },\n  "),a("span",{staticClass:"hljs-keyword"},[s._v("get")]),s._v(" a() {\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("._a_ \n  }\n};\n\n"),a("span",{staticClass:"hljs-built_in"},[s._v("Object")]),s._v(".defineProperty( \n  myObject, "),a("span",{staticClass:"hljs-comment"},[s._v("// 目标对象 ")]),s._v("\n  "),a("span",{staticClass:"hljs-string"},[s._v('"b"')]),s._v(", "),a("span",{staticClass:"hljs-comment"},[s._v("// 属性名")]),s._v("\n  {\n    "),a("span",{staticClass:"hljs-attr"},[s._v("set")]),s._v(": "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("val")]),s._v(")")]),s._v("{ "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("._b_ = val * "),a("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(" },\n    "),a("span",{staticClass:"hljs-comment"},[s._v("// 方式二:使用defineProperty在现有对象上定义 setter")]),s._v("\n    "),a("span",{staticClass:"hljs-attr"},[s._v("get")]),s._v(": "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{ "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("._b_ },\n    "),a("span",{staticClass:"hljs-comment"},[s._v("// 确保 b 会出现在对象的属性列表中")]),s._v("\n    "),a("span",{staticClass:"hljs-attr"},[s._v("enumerable")]),s._v(": "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v("\n   }\n);\n\nmyObject.a = "),a("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";  \nmyObject.b = "),a("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(";  \n"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(myObject.a); "),a("span",{staticClass:"hljs-comment"},[s._v("//4")]),s._v("\n"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(myObject.b);"),a("span",{staticClass:"hljs-comment"},[s._v("//9")]),s._v("\n\n"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(myObject._a_);"),a("span",{staticClass:"hljs-comment"},[s._v("//4")]),s._v("\n"),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(myObject._b_);"),a("span",{staticClass:"hljs-comment"},[s._v("//9")]),s._v("\n\n"),a("span",{staticClass:"hljs-keyword"},[s._v("delete")]),s._v(" myObject.a;"),a("span",{staticClass:"hljs-comment"},[s._v("//可以使用delete操作符删除")]),s._v("\n")])])]),a("h3",{attrs:{id:"存在性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存在性"}},[s._v("#")]),s._v(" 存在性")]),s._v(" "),a("p",[s._v("属性存在性:\t  \t\n如何判断一个对象是否存在某个属性(准确来说是检查这个属性名是否存在),这时就需要用到:")]),s._v(" "),a("p",[s._v("in操作符\nin 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。")]),s._v(" "),a("p",[s._v("hasOwnProperty(..)"),a("br"),s._v("\nhasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。")]),s._v(" "),a("p",[s._v("注意:")]),s._v(" "),a("ol",[a("li",[s._v('如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,"a")，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第2章)到 myObject 上。')]),s._v(" "),a("li",[s._v("对于数组来说,不要使用in操作符,因为它检查的是属性名,在数组中属性名就是索引,它并不是我们所关注的重点.对于数组我们更关注的是它所存的值,所以对于数组检查某个值是否存在还是采用indexOf方法.")])]),s._v(" "),a("p",[s._v("属性可枚举性:\t"),a("br"),s._v("\n如果一个属性存在,且它的enumerable 属性描述符为true时.则它是可枚举的.并且可以被for..in 循环.\t\n一个属性不仅仅需要存在,还需要它的enumerable 为true才是可枚举的,才能被for...in遍历到.\n注意: for...in不适合对数组进行遍历,对数组的遍历还是使用传统的for循环.\n对属性的可枚举性判断,则需要用到以下几种方法:")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。")])]),s._v(" "),a("li",[a("p",[s._v("Object.keys(..) 会返回一个数组，包含所有可枚举属性.")])]),s._v(" "),a("li",[a("p",[s._v("Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。")])])]),s._v(" "),a("h2",{attrs:{id:"遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[s._v("#")]),s._v(" 遍历")]),s._v(" "),a("p",[s._v("关于这节我觉得还是以理清for..in和for..of为主.后面延伸的@@iterator及Symbol.iterator的使用,没必要过于深究.注意书中123页第二行done 是一个布尔值，表示是否还有可以遍历的值。有个错误,应该改成done 是一个布尔值，表示遍历是否结束。否则你在看后面它的说明时会感觉到自相矛盾.这里我也是以for..in和for..of为主进行说明,也更贴近我们实际使用.")]),s._v(" "),a("p",[s._v("for..in")]),s._v(" "),a("ul",[a("li",[s._v("for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。")]),s._v(" "),a("li",[s._v("实际上for..in遍历的并不是属性值,而是属性名(即键名 key).所以你想获取属性值还是需要手动使用obj[key]来获取.")]),s._v(" "),a("li",[s._v("一般在遍历对象时,推荐使用for..in.当然数组也是可以使用for..in的.在遍历数组时,推荐还是使用for..of.")])]),s._v(" "),a("p",[s._v("for..of")]),s._v(" "),a("ul",[a("li",[s._v("ES6 增加了一种用来遍历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象)")]),s._v(" "),a("li",[s._v("for..of与for..in最大的不同点是,它循环的是属性值,而不是属性名.不过它只循环数组里存放的值,不会涉及到对象里的key.(关于这个我后面的例子里会说具体对比明的)")]),s._v(" "),a("li",[s._v("for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator，(对象没有,所以不能使用for..of,除非我们自己定义一个)因此 for..of 可以直接应用在数组上。")])]),s._v(" "),a("p",[s._v("例子比较")]),s._v(" "),a("div",{staticClass:"language-JavaScript extra-class"},[a("pre",[a("code",{staticClass:"language-JavaScript"},[a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" arr = ["),a("span",{staticClass:"hljs-string"},[s._v("'shotCat'")]),s._v(","),a("span",{staticClass:"hljs-number"},[s._v("111")]),s._v(",{"),a("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(":"),a("span",{staticClass:"hljs-string"},[s._v("'1'")]),s._v(","),a("span",{staticClass:"hljs-attr"},[s._v("b")]),s._v(":"),a("span",{staticClass:"hljs-string"},[s._v("'2'")]),s._v("}]\narr.say="),a("span",{staticClass:"hljs-string"},[s._v('"IG niu pi!"')]),s._v("\n"),a("span",{staticClass:"hljs-comment"},[s._v("//使用for..in循环")]),s._v("\n"),a("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("("),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index "),a("span",{staticClass:"hljs-keyword"},[s._v("in")]),s._v(" arr){\n  "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(arr[index]);"),a("span",{staticClass:"hljs-comment"},[s._v("//shotCat  111  {a:'1',b:'2'}  IG niu pi!")]),s._v("\n}\n"),a("span",{staticClass:"hljs-comment"},[s._v("//使用for..of循环")]),s._v("\n"),a("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v("("),a("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" value "),a("span",{staticClass:"hljs-keyword"},[s._v("of")]),s._v(" arr){\n  "),a("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(value);"),a("span",{staticClass:"hljs-comment"},[s._v("//shotCat  111  {a:'1',b:'2'}")]),s._v("\n}\n"),a("span",{staticClass:"hljs-comment"},[s._v("//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值,不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会)")]),s._v("\n")])])]),a("p",[s._v("如何让对象也能使用for..of ?")]),s._v(" "),a("p",[s._v("通过Object.defineProperty()定义一个Symbol.iterator属性来实现")]),s._v(" "),a("h2",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("ul",[a("li",[s._v("JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。")]),s._v(" "),a("li",[s._v("对象是 6 个(或者是 7 个，取决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。")]),s._v(" "),a("li",[s._v('对象就是键 / 值对的集合。可以通过 .propName 或者 ["propName"] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链(参见第 5 章)。')]),s._v(" "),a("li",[s._v("属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。")]),s._v(" "),a("li",[s._v("属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。")]),s._v(" "),a("li",[s._v("可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);