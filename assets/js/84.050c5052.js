(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{375:function(s,a,t){"use strict";t.r(a);var e=t(16),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[s._v("#")]),s._v(" 背景")]),s._v(" "),t("p",[s._v("通常，我们在需要保证代码在多个异步处理之后执行，会用到：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".all(promises: []).then(fun: "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(");\n")])])])]),t("p",[t("code",[s._v("Promise.all")]),s._v("可以保证，"),t("code",[s._v("promises")]),s._v("数组中所有promise对象都达到resolve状态，才执行"),t("code",[s._v("then")]),s._v("回调。")]),s._v(" "),t("p",[s._v("这时候考虑一个场景：如果你的"),t("code",[s._v("promises")]),s._v("数组中每个对象都是http请求，或者说每个对象包含了复杂的调用处理。而这样的对象有几十万个。")]),s._v(" "),t("p",[s._v("那么会出现的情况是，你在瞬间发出几十万http请求（tcp连接数不足可能造成等待），或者堆积了无数调用栈导致内存溢出。")]),s._v(" "),t("p",[s._v("这时候，我们就需要考虑对"),t("code",[s._v("Promise.all")]),s._v("做并发限制。")]),s._v(" "),t("p",[t("code",[s._v("Promise.all")]),s._v("并发限制指的是，每个时刻并发执行的promise数量是固定的，最终的执行结果还是保持与原来的"),t("code",[s._v("Promise.all")]),s._v("一致。")]),s._v(" "),t("p",[s._v("##实现")]),s._v(" "),t("p",[s._v("我们知道，promise并不是因为调用"),t("code",[s._v("Promise.all")]),s._v("才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，要实现并发限制，只能从promise实例化上下手。")]),s._v(" "),t("p",[s._v("换句话说，就是把生成"),t("code",[s._v("promises")]),s._v("数组的控制权，交给并发控制逻辑。")]),s._v(" "),t("p",[s._v("这里我并不打算一步步实现这个这个功能，npm中有很多实现这个功能的第三方包，比如"),t("a",{attrs:{href:"https://www.npmjs.com/package/tiny-async-pool",target:"_blank",rel:"noopener noreferrer"}},[s._v("async-pool"),t("OutboundLink")],1),s._v("、"),t("a",{attrs:{href:"https://www.npmjs.com/package/es6-promise-pool",target:"_blank",rel:"noopener noreferrer"}},[s._v("es6-promise-pool"),t("OutboundLink")],1),s._v("、"),t("a",{attrs:{href:"https://www.npmjs.com/package/p-limit",target:"_blank",rel:"noopener noreferrer"}},[s._v("p-limit"),t("OutboundLink")],1),s._v("，这里我直接拿async-pool的代码来分析一下实现原理。")]),s._v(" "),t("p",[s._v("代码很简单，去掉不必要的代码，加上自己的注释，大概内容如下：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("asyncPool")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("poolLimit, array, iteratorFn")]),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" i = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(";\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" ret = [];\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" executing = [];\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" enqueue = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 边界处理，array为空数组")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (i === array.length) {\n            "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve();\n        }\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 每调一次enqueue，初始化一个promise")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" item = array[i++];\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" p = "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve().then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" iteratorFn(item, array));\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 放入promises数组")]),s._v("\n        ret.push(p);\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// promise执行完毕，从executing数组中删除")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" e = p.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" executing.splice(executing.indexOf(e), "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("));\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 插入executing数字，表示正在执行的promise")]),s._v("\n        executing.push(e);\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 使用Promise.rece，每当executing数组中promise数量低于poolLimit，就实例化新的promise并执行")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" r = "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".resolve();\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (executing.length >= poolLimit) {\n            r = "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".race(executing);\n        }\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// 递归，直到遍历完array")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" r.then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" enqueue());\n    };\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" enqueue().then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v(".all(ret));\n}\n")])])]),t("p",[s._v("因为是promise加上递归，所以在代码注释上不太好标注执行顺序，但是大概的逻辑可以总结为：")]),s._v(" "),t("ol",[t("li",[s._v("从"),t("code",[s._v("array")]),s._v("第1个元素开始，初始化"),t("code",[s._v("promise")]),s._v("对象，同时用一个"),t("code",[s._v("executing")]),s._v("数组保存正在执行的promise")]),s._v(" "),t("li",[s._v("不断初始化promise，直到达到"),t("code",[s._v("poolLimt")])]),s._v(" "),t("li",[s._v("使用"),t("code",[s._v("Promise.race")]),s._v("，获得"),t("code",[s._v("executing")]),s._v("中promise的执行情况，当有一个promise执行完毕，继续初始化promise并放入"),t("code",[s._v("executing")]),s._v("中")]),s._v(" "),t("li",[s._v("所有promise都执行完了，调用"),t("code",[s._v("Promise.all")]),s._v("返回")])]),s._v(" "),t("p",[s._v("使用方式就是：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" timeout = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("i")]),s._v(" =>")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Promise")]),s._v("("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("resolve")]),s._v(" =>")]),s._v(" setTimeout("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("()")]),s._v(" =>")]),s._v(" resolve(i), i));\n"),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" asyncPool("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(", ["),t("span",{staticClass:"hljs-number"},[s._v("1000")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("5000")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("3000")]),s._v(", "),t("span",{staticClass:"hljs-number"},[s._v("2000")]),s._v("], timeout).then("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-params"},[s._v("results")]),s._v(" =>")]),s._v(" {\n    ...\n});\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("所谓promise并发限制，其实根源上就是控制promise的实例化。如果是通过第三方函数，那么就把创建promise的控制权交给第三方即可。")]),s._v(" "),t("p",[s._v("然而这样的实现效果，本质上来说已经抛弃了"),t("code",[s._v("Promise.all")]),s._v("而另辟蹊径。所以期待有一天promise标准能提供这个功能。")])])}),[],!1,null,null,null);a.default=n.exports}}]);