(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{347:function(s,t,a){"use strict";a.r(t);var n=a(16),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("title: 数据结构javascript描述：双向链表\nauthor: jsliushen\ntags:")]),s._v(" "),a("ul",[a("li",[s._v("数据结构\ncategories:")]),s._v(" "),a("li",[s._v("technology\ndate: 2017-12-09 23:37:00")])]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("上篇文章介绍了单链表，单链表中包含了一个存储元素本身的节点和指向下一个元素的引用。想在链表中查找某个元素，需要从表头开始迭代。这篇文章我们再来介绍一下双向链表。")]),s._v(" "),a("h3",{attrs:{id:"双向链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向链表"}},[s._v("#")]),s._v(" 双向链表")]),s._v(" "),a("p",[s._v("双向链表和单链表的区别在于，单链表中，一个节点只有指向下一个节点的指针，而在双向链表中，指针是双向的：一个指向下一个元素，一个指向前一个元素。双向链表有两种迭代的方法：从头到尾或者反过来从尾到头。我们可以访问某一节点的下一个或者前一个元素。在单链表中，如果迭代时错过了要找的元素，就需要回到表头，重新开始迭代。这也是双向链表优于单链表的地方。"),a("br"),s._v("\n双向链表中需要实现的方法和单链表中的类似，实现的思路也很类似。这里我们实现两个方法：")]),s._v(" "),a("ul",[a("li",[s._v("insert 向指定的位置插入元素")]),s._v(" "),a("li",[s._v("removeAt 从指定位置移除元素")])]),s._v(" "),a("p",[s._v("其余的方法大家可以参照实现，思路一样。\n首先来完成双向链表的构造函数：")]),s._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",[a("code",{staticClass:"language-javascript"},[a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("DoublyLinkedList")]),s._v("("),a("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n\t"),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),a("span",{staticClass:"hljs-title"},[s._v("Node")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("element")]),s._v(")")]),s._v("{\n    \t"),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".element = element;\n        "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".next = "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n        "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".pre = "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n    }\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" length = "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(";\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" head = "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" tail = "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".insert = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("position,element")]),s._v(")")]),s._v("{}\n    "),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".removeAt = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),a("span",{staticClass:"hljs-params"},[s._v("position")]),s._v(")")]),s._v("{}\n}\n")])])]),a("p",[s._v("对照单链表的够赞函数实现，这里有两处不同：一是节点构造函数中多了 "),a("code",[s._v("this.pre = null")]),s._v(" ，二是多了 "),a("code",[s._v("let tail = null;")]),s._v(" 这些变化也很好理解，双向链表相比于单项链表多出了对前一项的引用，同时也支持从尾到头的迭代。"),a("br"),s._v("\n下面我们来实现insert和removeAt方法。")]),s._v(" "),a("h4",{attrs:{id:"insert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#insert"}},[s._v("#")]),s._v(" insert")]),s._v(" "),a("p",[s._v("向链表的指定位置插入元素。参照单链表中的insert实现，思路如下：迭代寻找到指定位置对应的元素currentNode和前一项元素previousNode。添加的方式是将前一项previousNode和新创建的元素node链接，然后新创建的元素node和currentNode链接，这样就可以实现添加。和单链表不同的是，单链表只需指定next即可，而双向链表需要指定next和pre才算完全的添加成功。和单链表一样，插入元素时也有特殊的情况。第一种特殊情况是当指定的位置为0时，在表头前插入。这时候只需将新元素node的next指向原表头head，原表头的pre指向node，同时node作为作为新的表头。第二种特殊情况是链表为空时，这种情况下插入的元素是链表的第一个元素，既是head又是tail。第三种特殊情况是指定位置position等于链表长度length，这种情况相当于向链表的尾巴tail后面插入元素，需要将原tail.next指向新元素node，node的pre指向原尾巴，同时node作为链表新的tail。"),a("br"),s._v("\n说了这么多，来看代码：")]),s._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",[a("code",{staticClass:"language-javascript"},[s._v("\t"),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".insert = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),a("span",{staticClass:"hljs-params"},[s._v("position, element")]),s._v(") ")]),s._v("{\n    \t"),a("span",{staticClass:"hljs-comment"},[s._v("//先检测指定的位置是否符合规则")]),s._v("\n        "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position < "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(" || position > length) {\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("throw")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),a("span",{staticClass:"hljs-built_in"},[s._v("Error")]),s._v("("),a("span",{staticClass:"hljs-string"},[s._v('"索引超出范围"')]),s._v(");\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(";\n        } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n        \t"),a("span",{staticClass:"hljs-comment"},[s._v("//创建新的元素")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" node = "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Node(element);\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当前元素初始化为表头，准备迭代")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" currentNode = head;\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当前元素的索引，表头索引为0")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(",\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当前元素的前一项")]),s._v("\n            previousNode;\n            \n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当向表头前插入元素时")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position === "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") {\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//首先检测链表是不是空的")]),s._v("\n                "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!head) {\n                \t"),a("span",{staticClass:"hljs-comment"},[s._v("//如果链表是空的，新插入的元素既是表头又是表尾")]),s._v("\n                    head = node;\n                    tail = node;\n                } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n                \t"),a("span",{staticClass:"hljs-comment"},[s._v("//如果链表不是空的，在表头前添加元素")]),s._v("\n                    node.next = currentNode;\n                    "),a("span",{staticClass:"hljs-comment"},[s._v("//需要同时指定next和pre才算绑定完成")]),s._v("\n                    currentNode.pre = node;\n                    "),a("span",{staticClass:"hljs-comment"},[s._v("//新的元素成为新的表头")]),s._v("\n                    head = node;\n                }\n            } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position === length) {\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//向链表的尾巴后面添加元素时")]),s._v("\n                currentNode = node;\n                currentNode.next = node;\n                node.pre = currentNode;\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//当前元素成为新的表尾")]),s._v("\n                tail = node;\n            } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//向中间某处添加元素时，从表头开始迭代，找到position对应的元素")]),s._v("\n                "),a("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (index++ < position) {\n                    previousNode = currentNode;\n                    currentNode = currentNode.next;\n                }\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//循环结束时，currentNode代表positon对应的元素，previousNode代表前一项元素")]),s._v("\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//向previousNode和currentNode中间插入元素")]),s._v("\n                previousNode.next = node;\n                node.pre = previousNode;\n                node.next = currentNode;\n                currentNode.pre = node;\n            }\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//添加完成时，length加1")]),s._v("\n            length++;\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(";\n        }\n    }\n")])])]),a("p",[s._v("上面的代码有详细的注释说明，大家可以仔细对照查看，帮助理解。如果还有不懂的，欢迎留言讨论。")]),s._v(" "),a("h4",{attrs:{id:"removeat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#removeat"}},[s._v("#")]),s._v(" removeAt")]),s._v(" "),a("p",[s._v("从指定位置删除元素，思路和insert思路类似。从表头开始迭代，找到指定位置对应的元素currentNode，它的前一项previousNode，它的后一项nextNode。删除的方法和单链表类似，将前一项previousNode和后一项nextNode链接起来，跳过currentNode就相当于移除了当前元素。也有特殊情况，第一种是position等于0，这时移除的是表头，需要将原表头的下一项作为新的表头。第二中是position等于链表长度length，这时移除的是表尾，需要将原表尾的前一项作为新的表尾。")]),s._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",[a("code",{staticClass:"language-javascript"},[s._v("\t"),a("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".removeAt = "),a("span",{staticClass:"hljs-function"},[a("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),a("span",{staticClass:"hljs-params"},[s._v("position")]),s._v(") ")]),s._v("{\n    \t"),a("span",{staticClass:"hljs-comment"},[s._v("//先检测指定的位置是否符合规则")]),s._v("\n        "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position < "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(" || position >= length) {\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("throw")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),a("span",{staticClass:"hljs-built_in"},[s._v("Error")]),s._v("("),a("span",{staticClass:"hljs-string"},[s._v('"索引超出范围"')]),s._v(");\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n        } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n        \t"),a("span",{staticClass:"hljs-comment"},[s._v("//初始化当前项为head，准备迭代")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" currentNode = head;\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当前项的索引，head对应的索引为0")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" index = "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(",\n            previousNode;\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//当删除的是表头时")]),s._v("\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position === "),a("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(") {\n            \t"),a("span",{staticClass:"hljs-comment"},[s._v("//原表头的后一项将作为新的表头")]),s._v("\n                head = currentNode.next;\n            } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),a("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (position === length - "),a("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(") {\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//当删除的是表尾时")]),s._v("\n                currentNode = tail;\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//原表尾的前一项作为新的表尾")]),s._v("\n                tail = currentNode.pre;\n                tail.next = "),a("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n            } "),a("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//当删除的是中间某元素时，从表头开始迭代，找到position对应的元素")]),s._v("\n                "),a("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (index++ < position) {\n                    previousNode = currentNode;\n                    currentNode = currentNode.next;\n                }\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//删除currentNode，需要把currentNode的前一项和后一项链接起来")]),s._v("\n                previousNode.next = currentNode.next;\n                "),a("span",{staticClass:"hljs-comment"},[s._v("//需要同时指定next和pre才算绑定完成")]),s._v("\n                currentNode.next.pre = previousNode;\n            }\n            "),a("span",{staticClass:"hljs-comment"},[s._v("//删除完成时链表长度减1")]),s._v("\n            length--;\n            "),a("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" currentNode;\n        }\n    }\n")])])]),a("p",[s._v("双向链表的特点和两个方法都已经介绍完毕。其他的方法实现思路类似，大家可以参照单链表和上面的代码试着实现。")])])}),[],!1,null,null,null);t.default=e.exports}}]);