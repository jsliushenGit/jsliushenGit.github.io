(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{339:function(s,a,t){"use strict";t.r(a);var l=t(16),n=Object(l.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"函数中的作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数中的作用域"}},[s._v("#")]),s._v(" 函数中的作用域")]),s._v(" "),t("ul",[t("li",[s._v("JavaScript 具有基于函数的作用域，一般情况下每声明 一个函数都会创建一个函数作用域.")]),s._v(" "),t("li",[s._v("函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。")])]),s._v(" "),t("h2",{attrs:{id:"隐藏内部实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐藏内部实现"}},[s._v("#")]),s._v(" 隐藏内部实现")]),s._v(" "),t("p",[s._v("因为")]),s._v(" "),t("ul",[t("li",[s._v("子级函数作用域可以直接访问父级函数作用域里的标识符;")]),s._v(" "),t("li",[s._v("父级函数作用域不能直接访问子级函数作用域里的标识符.")])]),s._v(" "),t("p",[s._v("所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。")]),s._v(" "),t("p",[s._v('为什么要将代码进行"隐藏"?\t\n因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。')]),s._v(" "),t("p",[t("b",[s._v("隐藏的好处:")])]),s._v(" "),t("ol",[t("li",[s._v("实现代码私有化,减少外部对内部代码的干扰,保持其稳定性.")]),s._v(" "),t("li",[s._v("规避冲突: 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。那么一般规避冲突的手段有哪些?")])]),s._v(" "),t("ul",[t("li",[t("p",[s._v("全局命名空间: 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。")])]),s._v(" "),t("li",[t("p",[s._v("模块管理: 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd,commonjs,import模块机制.")])])]),s._v(" "),t("h2",{attrs:{id:"函数作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[s._v("#")]),s._v(" 函数作用域")]),s._v(" "),t("p",[s._v("函数声明与函数表达式:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n\t...\n}\n")])])]),t("p",[s._v("我们知道函数foo内的变量和函数被隐藏起来了,是不会对全局作用域造成污染.但是变量名foo仍然存在于全局作用域中,会造成污染.那有什么方法能避免函数名的污染呢?那就是作为函数表达式,而不是一个标准的函数声明.这样函数名只存在于它自己的函数作用域内,而不会存在于其父作用域,这样就没有了污染.举个函数声明的例子:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a = "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n("),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{ \n  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a = "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(";\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 3 ")]),s._v("\n})(); \n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n")])])]),t("p",[s._v("当我们用()包裹一个函数,并立即执行.此时这个包装函数声明是从(function开始的而不是从function关键字开始.这样foo就会被当做一个函数表达式,而不是一个函数声明(即foo不会存在于父级作用域中).回到上面的例子中,全局作用域是访问不到foo的,foo只存在于它自己的函数作用域中.")]),s._v(" "),t("p",[t("b",[s._v("补充: 什么是函数声明和函数表达式")]),s._v("\n首先我们得了解JS声明函数的三种方式:")]),s._v(" "),t("ul",[t("li",[s._v("函数表达式(Function Expression): 将函数定义为表达式语句（通常是变量赋值,也可以是自调用形式）的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名,因此常被用作匿名函数.如果有,其函数名也只存在自身的函数作用域.并且函数表达式不能以“function”开头.函数表达式可以存储在变量或者对象属性里. (在函数声明前加上运算符是可以将其转化为函数表达式的.例如!,+,-,().举个例子:!function(){console.log(1)}()的结果是1,并不会报错)")]),s._v(" "),t("li",[s._v("函数声明(Function Declaration):  函数声明是一种独立的结构,它会声明一个具名函数,并必须以function开头. 且函数声明会进行函数提升.使它能在其所在作用域的任意位置被调用,即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性.")]),s._v(" "),t("li",[s._v("Function()构造器: 即使用Function构造器创建函数.不推荐这种用法, 容易出问题")])]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-comment"},[s._v("//Function()构造器")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" f = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" "),t("span",{staticClass:"hljs-built_in"},[s._v("Function")]),s._v("()\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 函数表达式")]),s._v("\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" f = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v(");  \n}\n\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 函数声明")]),s._v("\n"),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("f")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(");\n}\n\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(f())\n"),t("span",{staticClass:"hljs-comment"},[s._v("//思考一下,这里会打印出什么")]),s._v("\n")])])]),t("p",[t("b",[s._v("怎么区分函数声明和函数表达式:")]),s._v("\n看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。例如上例中,是从(开始而不是function.")]),s._v(" "),t("h3",{attrs:{id:"匿名和具名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匿名和具名"}},[s._v("#")]),s._v(" 匿名和具名")]),s._v(" "),t("p",[s._v("函数表达式可以是匿名的，而函数声明则不可以省略函数名.有函数名的就是具名函数,没有函数名的就是匿名函数.\n匿名函数的缺点:")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。")])]),s._v(" "),t("li",[t("p",[s._v("如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。")])]),s._v(" "),t("li",[t("p",[s._v("匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。")])])]),s._v(" "),t("p",[s._v("所以给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践.")]),s._v(" "),t("h3",{attrs:{id:"立即执行函数表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数表达式"}},[s._v("#")]),s._v(" 立即执行函数表达式")]),s._v(" "),t("p",[s._v("比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式,也被称为IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression);\nIIFE可以具名也可以匿名.好处和上面提到的一样.IIFE还可以是这种形式(function(){ .. }()).这两种形式在功能上是一致的。")]),s._v(" "),t("h2",{attrs:{id:"块作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块作用域"}},[s._v("#")]),s._v(" 块作用域")]),s._v(" "),t("p",[s._v("函数作用域是JavaScript最常见的作用域单元,有时我们仅会将var赋值变量在if或for的{...}内使用,而不会在其他地方使用.但它仍然会对外层的函数作用域造成污染.这个时候就会希望能有一个作用域能将其外部的函数作用域隔开,声明的变量仅在此作用域有效.块作用域(通常就是{...}包裹的内部)就可以帮我们做到这点.")]),s._v(" "),t("p",[s._v("从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。")]),s._v(" "),t("h3",{attrs:{id:"with"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#with"}},[s._v("#")]),s._v(" with")]),s._v(" "),t("p",[s._v("我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。")]),s._v(" "),t("h3",{attrs:{id:"try-catch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#try-catch"}},[s._v("#")]),s._v(" try/catch")]),s._v(" "),t("p",[s._v("try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("try")]),s._v(" {\n  "),t("span",{staticClass:"hljs-literal"},[s._v("undefined")]),s._v("(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 执行一个非法操作来强制制造一个异常")]),s._v("\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("catch")]),s._v(" (err) {\n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( err ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 能够正常执行! ")]),s._v("\n}\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( err ); "),t("span",{staticClass:"hljs-comment"},[s._v("// ReferenceError: err not found")]),s._v("\n")])])]),t("p",[s._v("err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。\t\n那么如果我们想用catch创建一个不是仅仅接收err的块作用域,该怎么做呢?")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("try")]),s._v("{"),t("span",{staticClass:"hljs-keyword"},[s._v("throw")]),s._v(" "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";}"),t("span",{staticClass:"hljs-keyword"},[s._v("catch")]),s._v("(a){ \n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n}\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// ReferenceError")]),s._v("\n")])])]),t("p",[s._v("这样就创建了一个块作用域,且 a = 2 ,仅在catch分句中存在.在ES6之前我们可以使用这种方法来使用块作用域.")]),s._v(" "),t("h3",{attrs:{id:"let"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[s._v("#")]),s._v(" let")]),s._v(" "),t("p",[s._v("ES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。")]),s._v(" "),t("p",[s._v("用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。例如在if的{...}内用let声明一个变量.那什么是显式地创建块作用域呢?就是单独创建{}来作为let的块作用域.而不是借用if或者for提供的{}.例如"),t("code",[s._v("{let a=2;console.log(a)}")]),s._v("\n注意: 使用 let 进行的声明不会在块作用域中进行提升.")]),s._v(" "),t("p",[s._v("块作用域的好处:")]),s._v(" "),t("ol",[t("li",[s._v("垃圾收集")])]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("process")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("data")]),s._v(")")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 在这里做点有趣的事情")]),s._v("\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" someReallyBigData = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// dosomeing")]),s._v("\n}\nprocess(someReallyBigData);\n\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" btn = "),t("span",{staticClass:"hljs-built_in"},[s._v("document")]),s._v(".getElementById("),t("span",{staticClass:"hljs-string"},[s._v('"my_button"')]),s._v(");\nbtn.addEventListener("),t("span",{staticClass:"hljs-string"},[s._v('"click"')]),s._v(","),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("click")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("evt")]),s._v(")")]),s._v("{\n  alert("),t("span",{staticClass:"hljs-string"},[s._v('"button click"')]),s._v(");\n"),t("span",{staticClass:"hljs-comment"},[s._v("//假如我们在这里继续调用someReallyBigData就会形成闭包,导致不能垃圾回收(这段是书里没有,我加上方便理解的)")]),s._v("\n},"),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(");\n")])])]),t("p",[s._v("click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。\t\n但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("process")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("data")]),s._v(")")]),s._v("{\n       "),t("span",{staticClass:"hljs-comment"},[s._v("// 在这里做点有趣的事情")]),s._v("\n    }\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 在这个块中定义的内容可以销毁了! ")]),s._v("\n    {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" someReallyBigData = { .. }; \n      process( someReallyBigData );\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" btn="),t("span",{staticClass:"hljs-built_in"},[s._v("document")]),s._v(".getElementById("),t("span",{staticClass:"hljs-string"},[s._v('"my_button"')]),s._v(");\n    btn.addEventListener("),t("span",{staticClass:"hljs-string"},[s._v('"click"')]),s._v(","),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("click")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("evt")]),s._v(")")]),s._v("{\n       alert("),t("span",{staticClass:"hljs-string"},[s._v('"button click"')]),s._v(");\n    },"),t("span",{staticClass:"hljs-literal"},[s._v("false")]),s._v(");\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[s._v("let循环")])]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" i="),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("; i<"),t("span",{staticClass:"hljs-number"},[s._v("10")]),s._v("; i++) { \n\t  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( i );\n     }\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( i ); "),t("span",{staticClass:"hljs-comment"},[s._v("// ReferenceError")]),s._v("\n")])])]),t("p",[s._v("for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染.")]),s._v(" "),t("h3",{attrs:{id:"const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[s._v("#")]),s._v(" const")]),s._v(" "),t("p",[s._v("除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" foo = "),t("span",{staticClass:"hljs-literal"},[s._v("true")]),s._v(";\n"),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (foo) {\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a = "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("const")]),s._v(" b = "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// 包含在 if 中的块作用域常量")]),s._v("\n  a = "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// 正常!")]),s._v("\n  b = "),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// 错误! ")]),s._v("\n}\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 3")]),s._v("\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( b ); "),t("span",{staticClass:"hljs-comment"},[s._v("// ReferenceError!")]),s._v("\n")])])]),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),t("p",[s._v("函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开."),t("br"),s._v("\n但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域.")])])}),[],!1,null,null,null);a.default=n.exports}}]);