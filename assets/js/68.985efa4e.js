(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{338:function(s,a,t){"use strict";t.r(a);var v=t(16),i=Object(v.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"调用位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用位置"}},[s._v("#")]),s._v(" 调用位置")]),s._v(" "),t("p",[s._v("通过上节我们知道,this的绑定与函数的调用位置有关.调用位置就是函数在代码中被调用的位置")]),s._v(" "),t("p",[s._v("要寻找调用位置,最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中")]),s._v(" "),t("p",[s._v("其实分析调用栈只是为了在运行时找到我们关心的函数到底在哪里和被谁调用了. 但是实际别写代码时,其实并不会分析得这么清楚的,我们还是只需记住this的指向就是我们调用该函数的上下文对象.意思就是我们在哪里调用该函数,this就指向哪里.并且查看调用栈还可以通过浏览器的开发者工具,只需在疑惑的代码上一行加上debugger即可.浏览器在调试模式时,我们就可以在调用列表里查看调用栈.我们一般也仅在查找bug时,会使用该方法.")]),s._v(" "),t("h2",{attrs:{id:"绑定规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定规则"}},[s._v("#")]),s._v(" 绑定规则")]),s._v(" "),t("p",[s._v("在找到调用位置后,则需要判定代码属于下面四种绑定规则中的哪一种.然后才能对this进行绑定.\n注意: this绑定的是上下文对象,并不是函数自身也不是函数的词法作用域")]),s._v(" "),t("h3",{attrs:{id:"默认绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认绑定"}},[s._v("#")]),s._v(" 默认绑定")]),s._v(" "),t("p",[s._v("什么是独立函数调用:对函数直接使用而不带任何修饰的函数引用进行调用.简单点一个函数直接是func()这样调用,前面什么都没有.不同于通过对象属性调用例如obj.func(),也没有通过new关键字new Function();也没有通过apply,bind,call强制改变this指向.")]),s._v(" "),t("p",[s._v("默认绑定: 当被用作独立函数调用时（不论这个函数在哪被调用,不管全局还是其他函数内），this默认指向到window；")]),s._v(" "),t("p",[s._v("注意: 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined.")]),s._v(" "),t("h3",{attrs:{id:"隐式绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐式绑定"}},[s._v("#")]),s._v(" 隐式绑定")]),s._v(" "),t("p",[s._v("隐式绑定: 函数被某个对象拥有或者包含.也就是函数被作为对象的属性所引用.例如obj.func().此时this会绑定到该对象上.")]),s._v(" "),t("p",[s._v("隐式丢失: 不管是通过函数别名或是将函数作为入参造成的隐式丢失.只需找到它真正的调用位置,并且函数前没有任何修饰也没有显式绑定(下节会讲到)(非严格模式下).那么this则会进行默认绑定,指向window.")]),s._v(" "),t("p",[s._v("注意: 实际工作中,大部分this使用错误都是由对隐式丢失的不理解造成的.记住函数调用前没有任何修饰和显式绑定(其实就是call、apply、bind),this就指向window")]),s._v(" "),t("h3",{attrs:{id:"显式绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显式绑定"}},[s._v("#")]),s._v(" 显式绑定")]),s._v(" "),t("p",[s._v("在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，此时则需要显式绑定.")]),s._v(" "),t("p",[s._v("显式绑定:  可以直接指定 this 的绑定对象，被称之为显式绑定。基本上就是我们常使用的call、apply、bind方法都是显式绑定")]),s._v(" "),t("p",[s._v("注意:"),t("br"),s._v("\n如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。")]),s._v(" "),t("p",[s._v("硬绑定: 使用call、apply、bind方法强制显式地将this进行绑定,称之为硬绑定。\t\n硬绑定的典型应用场景就是创建一个包裹函数(其实就是常说的封装函数)，传入所有的参数并返回接收到的所有值.\t\n在封装函数中,我们常使用apply.一方面是因为它可以手动绑定this,更重要的是因为可以用apply的第二个参数,方便地注入所有传入的参数.例如之前提到的modules[name]=impl.apply(impl,deps).因为我们不知道传入的参数有多少个,但我们可以方便地使用一个deps将其全部注入.另一个常用的是foo.apply( null,argue)当我们将apply的第一个参数设置为null时,此时this就会默认绑定到window.切记使用这种用法时确保函数foo内没有使用this. 否则很可能会造成全局污染.如果是第三方库的函数就建议不要使用了,因为你不知道别人的函数是否使用了this(关于这部分内容,下节会继续提到).还有一种常用就是foo.call( this).这样foo里的this都会指向当前调用的上下文环境.")]),s._v(" "),t("p",[s._v("API调用的“上下文”: 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。")]),s._v(" "),t("h3",{attrs:{id:"new绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new绑定"}},[s._v("#")]),s._v(" new绑定")]),s._v(" "),t("p",[s._v("JavaScript 中 new 的机制实际上和面向类的语言完全不同。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。")]),s._v(" "),t("p",[s._v("使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。")]),s._v(" "),t("ol",[t("li",[s._v("创建(或者说构造)一个全新的对象。")]),s._v(" "),t("li",[s._v("这个新对象会被执行[[原型]]连接。")]),s._v(" "),t("li",[s._v("这个新对象会绑定到函数调用的this。")]),s._v(" "),t("li",[s._v("如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。")])]),s._v(" "),t("p",[s._v("示例:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),t("span",{staticClass:"hljs-params"},[s._v("a")]),s._v(") ")]),s._v("{ \n  "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".a = a;\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" bar = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" foo("),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("); \n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( bar.a ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n")])])]),t("p",[s._v("使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。\n说明:对于上面这句话进行解释下,如果在一个函数前面带上 new 关键字来调用， 那么背地里将会创建一个连接到该函数的 prototype 的新对象，this就指向这个新对象；")]),s._v(" "),t("h2",{attrs:{id:"优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[s._v("#")]),s._v(" 优先级")]),s._v(" "),t("p",[s._v("直接上结论:\nnew绑定=显示绑定>隐式绑定>默认绑定\n说明: new绑定与显示绑定是不能直接进行测试比较,但通过分析发现new绑定内部其实是使用了硬绑定(显示绑定的一种),所以new绑定和显示绑定优先级应该差不多.但话说回来,一般实际使用时,不会这种复杂的交错绑定.所以只需记住下面的判定即可.")]),s._v(" "),t("p",[s._v("判断this:")]),s._v(" "),t("p",[s._v("现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断:")]),s._v(" "),t("ol",[t("li",[s._v("函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。  var bar = new foo()")]),s._v(" "),t("li",[s._v("函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。var bar = foo.call(obj2)")]),s._v(" "),t("li",[s._v("函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo()")]),s._v(" "),t("li",[s._v("如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。var bar = foo()\n就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。")])]),s._v(" "),t("h2",{attrs:{id:"绑定例外"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#绑定例外"}},[s._v("#")]),s._v(" 绑定例外")]),s._v(" "),t("h3",{attrs:{id:"被忽略的this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#被忽略的this"}},[s._v("#")]),s._v(" 被忽略的this")]),s._v(" "),t("p",[s._v("如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则,this会绑定到window上.")]),s._v(" "),t("p",[s._v("使用情景:")]),s._v(" "),t("p",[s._v("一种非常常见的做法是使用 apply(..) 来“展开”一个数组(也可以用来方便地参数注入)，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数).通过自带bind方法实现柯里化是很方便的,比自己写要简化好多.\n注意:")]),s._v(" "),t("ul",[t("li",[s._v("在 ES6 中，可以用 ... 操作符代替 apply(..) 来“展 开”数组，foo(...[1,2]) 和 foo(1,2)是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。")]),s._v(" "),t("li",[s._v("当使用null或者undefined进行绑定时,要确保该函数内没有使用this,否则此时很容易对全局变量造成破坏!尤其是使用第三方库的方法!")])]),s._v(" "),t("p",[s._v("更安全的this")]),s._v(" "),t("p",[s._v('如果函数内使用了this,直接使用null则可能会对全局造成破坏.因此我们可以通过创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。让this绑定到这个"DMZ上.这样就不会对全局造成破坏.\t\n怎么创建DMZ呢.就是通过Object.create(null) 创建一个空对象.这种方法和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”更加安全.')]),s._v(" "),t("h3",{attrs:{id:"间接引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#间接引用"}},[s._v("#")]),s._v(" 间接引用")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{ \n  "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".a );\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" a = "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v(";\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" o = { "),t("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("3")]),s._v(", "),t("span",{staticClass:"hljs-attr"},[s._v("foo")]),s._v(": foo }; \n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" p = { "),t("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("4")]),s._v(" };\no.foo(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 3")]),s._v("\n(p.foo = o.foo)(); "),t("span",{staticClass:"hljs-comment"},[s._v("// 2  其实就是foo()  此时this默认绑定到window")]),s._v("\n")])])]),t("p",[s._v("例子中的间接引用其实是对函数的理解不深造成的.其实(p.foo = o.foo)()就是(foo)(),这样就是全局调用foo()所以this默认就绑定到了window上.")]),s._v(" "),t("p",[s._v("注意:\t\t\n对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。")]),s._v(" "),t("h3",{attrs:{id:"软绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软绑定"}},[s._v("#")]),s._v(" 软绑定")]),s._v(" "),t("p",[s._v("硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。这时候则需要使用软绑定.")]),s._v(" "),t("h2",{attrs:{id:"this词法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this词法"}},[s._v("#")]),s._v(" this词法")]),s._v(" "),t("p",[s._v("ES6 中介绍了一种无法使用上面四条规则的特殊函数类型:箭头函数。"),t("br"),s._v("\n箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。(而传统的this与函数作用域没有任何关系,它只与调用位置的上下文对象有关.这点在本章开头就已经反复强调了.)")]),s._v(" "),t("p",[s._v("重要:")]),s._v(" "),t("ul",[t("li",[s._v("箭头函数最常用于回调函数中，例如事件处理器或者定时器.")]),s._v(" "),t("li",[s._v("箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象")]),s._v(" "),t("li",[s._v("箭头函数用更常见的词法作用域取代了传统的 this 机制。")])]),s._v(" "),t("p",[s._v("注意: 这种情况:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("module")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".x;\n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" foo = {\n  "),t("span",{staticClass:"hljs-attr"},[s._v("x")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("99")]),s._v(",\n  "),t("span",{staticClass:"hljs-attr"},[s._v("bar")]),s._v(":"),t("span",{staticClass:"hljs-built_in"},[s._v("module")]),s._v(".bind("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(") "),t("span",{staticClass:"hljs-comment"},[s._v("//此时bind绑定的this为window.")]),s._v("\n  \n}\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" x="),t("span",{staticClass:"hljs-string"},[s._v('"window"')]),s._v("\n\n"),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log(foo.bar())"),t("span",{staticClass:"hljs-comment"},[s._v("//window")]),s._v("\n")])])]),t("p",[s._v("在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式:")]),s._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",[t("code",{staticClass:"language-JavaScript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("foo")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" self = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("; "),t("span",{staticClass:"hljs-comment"},[s._v("// lexical capture of this ")]),s._v("\n  setTimeout( "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(")")]),s._v("{\n             "),t("span",{staticClass:"hljs-built_in"},[s._v("console")]),s._v(".log( self.a );\n         }, "),t("span",{staticClass:"hljs-number"},[s._v("100")]),s._v(" );\n  }\n"),t("span",{staticClass:"hljs-keyword"},[s._v("var")]),s._v(" obj = { \n    "),t("span",{staticClass:"hljs-attr"},[s._v("a")]),s._v(": "),t("span",{staticClass:"hljs-number"},[s._v("2")]),s._v("\n};\nfoo.call( obj ); "),t("span",{staticClass:"hljs-comment"},[s._v("// 2")]),s._v("\n")])])]),t("p",[s._v("虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。(的确是这样,我一般会用me替代self.因为少两个单词=.=)")]),s._v(" "),t("p",[s._v("关于this的编码规范建议:")]),s._v(" "),t("ul",[t("li",[s._v("只使用词法作用域并完全抛弃错误this风格的代码;")]),s._v(" "),t("li",[s._v("完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。")])]),s._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),t("p",[s._v("如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。")]),s._v(" "),t("ul",[t("li",[s._v("由new调用?绑定到新创建的对象。")]),s._v(" "),t("li",[s._v("由call或者apply(或者bind)调用?绑定到指定的对象。")]),s._v(" "),t("li",[s._v("由上下文对象调用?绑定到那个上下文对象。")]),s._v(" "),t("li",[s._v("默认:在严格模式下绑定到undefined，否则绑定到全局对象。")])]),s._v(" "),t("p",[s._v("一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。")]),s._v(" "),t("p",[s._v("ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。")])])}),[],!1,null,null,null);a.default=i.exports}}]);