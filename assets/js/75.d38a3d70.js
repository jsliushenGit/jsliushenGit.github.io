(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{341:function(a,v,t){"use strict";t.r(v);var _=t(16),r=Object(_.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"类理论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类理论"}},[a._v("#")]),a._v(" 类理论")]),a._v(" "),t("p",[a._v("说明:")]),a._v(" "),t("ul",[t("li",[a._v("类其是描述了一种代码的组织结构形式.")]),a._v(" "),t("li",[a._v("在js中类常见的就是构造函数,也可以是通过ES6提供的class关键字;继承就是函数;实例化就是对象,常见的就是通过new构造函数实现的.")])]),a._v(" "),t("p",[a._v('注意: Javascript语言不支持“类”，所谓的"类"也是模拟出的“类”。即使是ES6引入的"类"实质上也是 JavaScript 现有的基于原型的继承的语法糖。')]),a._v(" "),t("h3",{attrs:{id:"类-设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类-设计模式"}},[a._v("#")]),a._v(" “类”设计模式")]),a._v(" "),t("p",[a._v("一句话:类其实也是一种设计模式!")]),a._v(" "),t("ul",[t("li",[a._v("类并不是必须的编程基础,而是一种可选的代码抽象.")]),a._v(" "),t("li",[a._v("有些语言(比如 Java)并不会给你选择的机会，类并不是可选的——万物皆是类。")]),a._v(" "),t("li",[a._v("其他语言(比如 C/C++ 或者 PHP)会提供过程化和面向类这两种语法，开发者可以选择其中一种风格或者混用两种风格。")])]),a._v(" "),t("h3",{attrs:{id:"javascript中的-类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript中的-类"}},[a._v("#")]),a._v(" JavaScript中的“类”")]),a._v(" "),t("p",[a._v("JavaScript 只有一些近似类的语法元素 (比如 new 和 instanceof)，不过在后来的 ES6 中新增了一些元素，比如 class 关键字,其实质上也是 JavaScript 现有的基于原型的继承的语法糖。也不是真正的类.")]),a._v(" "),t("h2",{attrs:{id:"类的机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的机制"}},[a._v("#")]),a._v(" 类的机制")]),a._v(" "),t("p",[a._v('在JavaScript里"类"主要是构造函数,"实例"就是对象.\n一个类就像一张蓝图。为了获得真正可以交互的对象，我们必须按照类来实例化一个东西，这个东西(对象)通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。\n总而言之:类通过实例化得到实例对象.')]),a._v(" "),t("h3",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),t("ul",[t("li",[a._v("类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。")]),a._v(" "),t("li",[a._v("实例就是由构造函数实例化的: new 构造函数.")]),a._v(" "),t("li",[a._v("构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。")]),a._v(" "),t("li",[a._v("构造函数会返回一个对象,这个对象就是实例.这个对象可以调用类的方法.")])]),a._v(" "),t("h2",{attrs:{id:"类的继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的继承"}},[a._v("#")]),a._v(" 类的继承")]),a._v(" "),t("p",[a._v("在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。子类可以继承父类的行为,并且可以根据自己的需求,修改继承的行为(一般并不会修改父类的行为).注意:我们讨论的父类和子类并不是实例,在JavaScript里类一般都是构造函数。")]),a._v(" "),t("h3",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),t("p",[a._v('大概你看了它的"解释",对多态还是懵懵懂懂.这里我再解释下:\n什么是多态?\n同一个操作，作用于不同的对象，会产生不同的结果。发出一个相同的指令后，不同的对象会对这个指令有不同的反应，故称为多态。')]),a._v(" "),t("ul",[t("li",[a._v("相对性: 其实相对性就是子类相对于父类的引用(例如使用super实现引用),并且子类对父类的引用并不会对父类的行为造成任何影响(并不会对父类自身的行为进行重新定义),例如书中例子子类对drive()的引用.")]),a._v(" "),t("li",[a._v("可重复定义: 子类继承父类的某个方法,并可以对这个方法进行再次定义,例如书中子类对drive()中的output进行修改.当调用方法时会自动选择合适的定义,这句话怎么理解,当子类实例化后,执行drive()方法时,它并不会直接去执行父类的drive().而是子类上的drive().简单来说就是实例来源于那个类,它就使用那个类的方法.")])]),a._v(" "),t("h3",{attrs:{id:"多重继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多重继承"}},[a._v("#")]),a._v(" 多重继承")]),a._v(" "),t("ul",[t("li",[a._v("多重继承: 一个子类可以继承来自多个父类的方法.")]),a._v(" "),t("li",[a._v("多重继承引发的问题: 多重继承可能会出现,多个父类中方法名冲突的问题,这样子类到底引用哪个方法?")]),a._v(" "),t("li",[a._v("多重继承与JavaScript: JavaScript本身并没有提供多重继承功能.但它可以通过其他方法来达到多重继承的效果.")])]),a._v(" "),t("h2",{attrs:{id:"混入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#混入"}},[a._v("#")]),a._v(" 混入")]),a._v(" "),t("p",[a._v('JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来(参见第 5 章)(其实就是引用,所以它的多态是"相对"的)。\t\n由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入(就是通过混入来模拟实现类的多重继承)。')]),a._v(" "),t("h3",{attrs:{id:"显式混入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#显式混入"}},[a._v("#")]),a._v(" 显式混入")]),a._v(" "),t("p",[a._v("显式混入:  书中没有给出明确的显式混入的定义,但是读完整章.基本就知道什么是显式混入了.显式混入就是通过类似mixin()方法,显式地将父对象属性逐一复制,或者有选择地复制(即例子中的存在性检查)到子对象上.")]),a._v(" "),t("p",[a._v("显式混入常用方法: 就是书中的例子, 首先有子对象,并对其进行特殊化(定义自己的属性或方法).然后再通过mixin()方法将父对象有选择地复制(即存在性检查,过滤子对象已有的属性,避免冲突)到子对象上.\n显式混入注意点:")]),a._v(" "),t("p",[a._v("显式混入时,切记一点你要避免父对象的属性与子对象特殊化的属性冲突.这就是为什么例子中要进行存在性检查,以及后面要说的混合复制,可能存在的重写风险.")]),a._v(" "),t("ol",[t("li",[a._v('再说多态(其实说的就是js里的多态)\n显式多态: 将父对象里的方法通过显式绑定到子对象上.就是显式多态.例如书中的例子:Vehicle.drive.call( this )。显式多态也是为了JS来模拟实现多重继承的!\n说明: 在ES6之前是没有相对多态的机制。所以就使用call这种进行显式绑定实现显式动态.注意JavaScript里实现多态的方法也被称为"伪多态".所以不要对后面突然冒出的伪多态概念而一脸懵逼(其实整本书经常做这样的事)\n显式多态(伪多态)的缺陷: 因为在JavaScript 中存在屏蔽(实际是函数引用的上下文不同),所以在引用的时候就需要使用显式伪多态的方法创建一个函数关联.   这些都会增加代码的复杂度和维护难度(过多的this绑定,真的会让代码很难读)。')]),a._v(" "),t("li",[a._v("混合复制(显式混入另一种不常用方法)\n前面的显式混入的方法是先有子对象并进行特殊化,然后再有选择地复制父对象属性.这个不常用的方法则是反过来的,结合书中例子,它先用一个空对象完全复制父对象的属性,然后该对象复制特殊化对象的属性,最后得到子对象.这种方法明显是比第一种麻烦的,并且在复制特殊化对象时,可能会对之前重名的属性(即复制得到的父对象属性)进行重写覆盖.所以这种方法是存在风险,且效率低下的.")])]),a._v(" "),t("p",[t("b",[a._v("显式混入的缺陷:")])]),a._v(" "),t("ul",[t("li",[a._v("无法做到真正的复制: 如果复制的对象中存在对函数的引用,那么子对象得到的是和父对象一样的,对同一个函数的引用.如果某个子对象对函数进行了修改,那么父对象及其他子对象都会受到影响.很明显这是不安全的.原因是JavaScript 中的函数无法进行真正地复制，你只能复制对共享函数对象的引用.")]),a._v(" "),t("li",[a._v("函数名和属性名同名: 如果混入多个对象,则可能会出现这种情况.目前现在仍没有比较好的方式来处理函数和属性的同名问题(提问:这种情况下谁的优先级更高?滑稽脸)。")])]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("寄生继承\n显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的.\t\n首先会复制一份父类(对象)的定义，然后混入子类(对象)的定义(如果需要的话保留到父类的特殊引用)，然后用这个复合对象构建实例。")])]),a._v(" "),t("p",[a._v('说明: 寄生继承与混合复制是很相似的,最大的区别是寄生继承是通过实例化构造函数(JS中的"类")来实现复制的.')]),a._v(" "),t("h3",{attrs:{id:"隐式混入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#隐式混入"}},[a._v("#")]),a._v(" 隐式混入")]),a._v(" "),t("p",[a._v("隐式混入: 它与显示混入最大的区别,就是它没有明显的对父类(对象)属性进行复制的过程.它是通过在构造函数调用或者方法调用中使用显式绑定例如: Something.cool.call( this)来实现混入(多重继承).其本质就是通过改变this指向来实现混入.")]),a._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),t("p",[a._v("整章的重点其实就是让你理解什么叫类.除了最后一小节的混入和JavaScript有那么一点点关系.其余的小结和JavaScript都没什么关系.重要的是理解类这种思想和设计模式.")]),a._v(" "),t("ul",[t("li",[a._v("传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。")]),a._v(" "),t("li",[a._v("多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。")]),a._v(" "),t("li",[a._v("JavaScript 并不会(像类那样)自动创建对象的副本。(你只能自己手动复制,而且复制的还不彻底!)")]),a._v(" "),t("li",[a._v("混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态(OtherObj.methodName.call(this, ...))，这会让代码更加难 懂并且难以维护。")]),a._v(" "),t("li",[a._v("显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。")]),a._v(" "),t("li",[a._v("在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。(但实际,我们用得却很多)")])])])}),[],!1,null,null,null);v.default=r.exports}}]);