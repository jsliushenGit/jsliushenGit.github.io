(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{353:function(s,a,t){"use strict";t.r(a);var l=t(16),v=Object(l.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("title: 数据结构javascript描述：树（1）\nauthor: jsliushen\ntags:")]),s._v(" "),t("ul",[t("li",[s._v("数据结构\ncategories:")]),s._v(" "),t("li",[s._v("technology\ndate: 2017-12-23 23:22:00")])]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("树是一种分层结构的抽象模型，树通常用来存储需要快速查找的数据。在我们现实生活中，树形结构有很多，比如公司的组织架构图、家谱等。 树结构和之前的链表，集合相比要复杂很多，为了避免篇幅过长，我决定分几篇文章来介绍树以及它的常用方法。")]),s._v(" "),t("h3",{attrs:{id:"树的相关概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树的相关概念"}},[s._v("#")]),s._v(" 树的相关概念")]),s._v(" "),t("p",[t("img",{attrs:{src:"/images/Tree/binarySearchTree.png",alt:"借的百度的图"}})]),s._v(" "),t("p",[s._v("上图就是一个树结构，下面我们对照图来介绍几个树相关的概念"),t("br"),s._v("\n根节点：在树中，每个元素都被称为节点，树顶部的节点被称为根节点。也就是图中15对应的节点")]),s._v(" "),t("p",[s._v("父节点和子节点：这两个概念用于描述节点之间的关系，图中上下层通过线链接起来的节点具有父子关系，上层的被称为父节点，下层的被称为子节点。比如图中的6，7对应的两个节点，6是7的父节点，7是6的子节点。当然与之对应的还有爷爷节点和孙子节点，这个就不介绍了。关于子节点还有一点说明，图中的6有两个子节点，分别是3和7，这个两个子节点的称呼也不同，左侧的3被称为左侧子节点，右侧的7被称为右侧子节点。")]),s._v(" "),t("p",[s._v("叶节点：一般树中的节点都存在父节点和子节点，但是有些节点比较特殊，比如根节点没有父节点，还有一种节点没有子节点，这种节点被称为叶节点（可以类比树的叶子），也被称为外部节点。")]),s._v(" "),t("p",[s._v("深度：这个概念是对于节点而言的，深度是指一个节点的祖先节点的数量，也就是说从该节点到根节点隔了多少代。比如图中的节点13，它有父节点7，节点7有父节点6，6有父节点15，15是根节点，不存在父节点，所以这里节点13的深度是3。")]),s._v(" "),t("p",[s._v("子树：子树是由节点和后代构成的，类似上篇文章集合中的子集，这里的子树和原本的树也是一种包含关系。比如图中3，2，4三个节点也可以构成树，这个树就是一个子树，是整体的一部分。")]),s._v(" "),t("p",[s._v("高度：树的高度取决于所有节点深度的最大值。对照图可以很直观的看到，节点9处在树的最底端，它的深度是4，所以树的高度是4。")]),s._v(" "),t("h3",{attrs:{id:"二叉树和二叉搜索树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二叉树和二叉搜索树"}},[s._v("#")]),s._v(" 二叉树和二叉搜索树")]),s._v(" "),t("p",[s._v("理论上一个节点可以有0到正无穷个子节点，但是这种不规则的树研究意义不大。在计算机科学中我们研究和应用的树最多只有两个子节点，这种树被称为二叉树。二叉搜索树（也被称为二叉查找树）是二叉树的一种，它的特点是：左侧子节点的值小于父节点，右侧子节点的值大于或等于父节点。上图中的树就是一个典型的二叉搜索树，我们也只模拟实现二叉搜索树。"),t("br"),s._v("\n再次观察上图，我们来总结一下二叉搜索树的特点：")]),s._v(" "),t("ol",[t("li",[s._v("任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；")]),s._v(" "),t("li",[s._v("任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；")]),s._v(" "),t("li",[s._v("任意节点的左、右子树也分别为二叉查找树；")]),s._v(" "),t("li",[s._v("没有相等的节点。")])]),s._v(" "),t("p",[s._v("下面我们先用代码模拟一下树的基本结构：")]),s._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",[t("code",{staticClass:"language-javascript"},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("BinarySearchTree")]),s._v("("),t("span",{staticClass:"hljs-params"}),s._v(") ")]),s._v("{\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" Node = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("function")]),s._v(" ("),t("span",{staticClass:"hljs-params"},[s._v("key")]),s._v(") ")]),s._v("{\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".key = key;\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".left = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".right = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("let")]),s._v(" root = "),t("span",{staticClass:"hljs-literal"},[s._v("null")]),s._v(";\n}\n")])])]),t("p",[s._v("这个代码和我们之前的链表很相似。在链表中，除了存储值本身，还需要存储指向上一个节点和下一个节点的指针，同时还会给出变量表示链表的表头和表尾。在上面的代码中，声明了节点的构造函数Node，代码很好理解，存储值本身的key，存储左侧子节点的left和存储右侧子节点的right。root用于存储树的根节点。"),t("br"),s._v("\n本片文章到这里就结束了，下篇文章我们再来实现树相关的方法。")])])}),[],!1,null,null,null);a.default=v.exports}}]);